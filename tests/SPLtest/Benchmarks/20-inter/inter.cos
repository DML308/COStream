//注：continue后端生成有问题！！后端代码未生成该语句！！
//2NxnD中uiPartAddr有问题！！

#define UInt unsigned int
//#define bool bool   //costream不支持bool类型，用unsigned char型代替
#define bool int
#define Pel short
#define Int int
#define Double double
#define Float float
#define Char char
#define UChar unsigned char
#define NULL 0x0000000000000000
#define true 1
#define false 0

#define MAX_UINT                    0xFFFFFFFFU ///< max. value of unsigned 32-bit integer
#define MAX_INT                     2147483647  ///< max. value of signed 32-bit integer
#define MAX_INT64                   0x7FFFFFFFFFFFFFFFLL  ///< max. value of signed 64-bit integer
#define MAX_DOUBLE                  1.7e+308    ///< max. value of double-type value

//typedef       long Int64;  //8 bytes
//typedef       unsigned long  UInt64 //8 bytes

typedef       long long         Int64;   //在linux下测试大小为 8 bytes
typedef       unsigned long long  UInt64;//在linux下测试大小为 8 bytes

struct TComDataCU;  //前向声明结构体
typedef struct TComDataCU TComDataCU;

struct TComSlice
{
	Double      m_lambdas[3];
	Int         m_iDepth;
	Int  m_aiNumRefIdx[2];    //  for multiple reference of current slice
	bool m_bLMvdL1Zero;
	Int  m_list1IdxToList0Idx[16];
};
typedef struct TComSlice TComSlice; 

struct TComPicSym
{
	UInt          m_uiWidthInCU;
	UInt          m_uiHeightInCU;
  
	UInt          m_uiMaxCUWidth;
	UInt          m_uiMaxCUHeight;
	UInt          m_uiMinCUWidth;
	UInt          m_uiMinCUHeight;
  
	UChar         m_uhTotalDepth;       ///< max. depth
	UInt          m_uiNumPartitions;
	UInt          m_uiNumPartInWidth;
	UInt          m_uiNumPartInHeight;
	UInt          m_uiNumCUsInFrame;
	
	TComSlice**   m_apcTComSlice;
	TComDataCU**  m_apcTComDataCU; 	
};

typedef struct TComPicSym TComPicSym;

struct TComPicYuv
{
  Pel*  m_apiPicBufY;           ///< Buffer (including margin)
  Pel*  m_apiPicBufU;
  Pel*  m_apiPicBufV;
  
  Pel*  m_piPicOrgY;            ///< m_apiPicBufY + m_iMarginLuma*getStride() + m_iMarginLuma
  Pel*  m_piPicOrgU;
  Pel*  m_piPicOrgV;
  
  // ------------------------------------------------------------------------------------------------
  //  Parameter for general YUV buffer usage
  // ------------------------------------------------------------------------------------------------
  
  Int   m_iPicWidth;            ///< Width of picture
  Int   m_iPicHeight;           ///< Height of picture
  
  Int   m_iCuWidth;             ///< Width of Coding Unit (CU)
  Int   m_iCuHeight;            ///< Height of Coding Unit (CU)
  Int*  m_cuOffsetY;
  Int*  m_cuOffsetC;
  Int*  m_buOffsetY;
  Int*  m_buOffsetC;
  
  Int   m_iLumaMarginX;
  Int   m_iLumaMarginY;
  Int   m_iChromaMarginX;
  Int   m_iChromaMarginY;
  
  bool  m_bIsBorderExtended;
};

typedef struct TComPicYuv TComPicYuv;

struct TComPic
{
	
	UInt                  m_uiTLayer;               //  Temporal layer
	bool                  m_bUsedByCurr;            //  Used by current picture
	bool                  m_bIsLongTerm;            //  IS long term picture
	
	TComPicSym*           m_apcPicSym;  
	TComPicYuv*           m_apcPicYuv[2];           //  Texture,  0:org / 1:rec
  
    TComPicYuv*           m_pcPicYuvPred;           //  Prediction
    TComPicYuv*           m_pcPicYuvResi;           //  Residual
	
};
typedef struct TComPic TComPic;


struct TComMv
{
	short m_iHor;
	short m_iVer;
};
typedef struct TComMv TComMv;

struct TComMvField
{
	TComMv m_acMv;
	Int    m_iRefIdx;
};
typedef struct TComMvField TComMvField;

typedef struct _AMVPInfo
{
	TComMv m_acMvCand[3];  ///< array of motion vector predictor candidates
    Int    iN;                                ///< number of motion vector predictor candidates
}AMVPInfo;

struct TComCUMvField
{
  TComMv*   m_pcMv;
  TComMv*   m_pcMvd;
  Char*     m_piRefIdx;
  UInt      m_uiNumPartition;
  AMVPInfo  m_cAMVPInfo;  
};
typedef struct TComCUMvField TComCUMvField;


struct TComDataCU
{
	UInt m_uiCUAddr;
	UInt m_uiAbsIdxInLCU;
	UInt          m_uiCUPelX;           ///< CU position in a pixel (X)
    UInt          m_uiCUPelY;  
	TComPic*      m_pcPic;              ///< picture class pointer
	TComSlice*    m_pcSlice;            ///< slice header pointer
	
	UChar* m_puhDepth;  
	bool* m_skipFlag;
	Char* m_pePartSize;
	Char* m_pePredMode;         ///< array of prediction modes
	Char* m_CUTransquantBypass;
	//bool* m_CUTransquantBypass;   ///< array of cu_transquant_bypass flags
	Char* m_phQP;               ///< array of QP values
	
	UChar* m_puhTrIdx;
	UChar* m_puhCbf[3];  
	UChar* m_puhTransformSkip[3];
    TComCUMvField m_acCUMvField[2];     ///< array of motion vectors
	UChar* m_puhLumaIntraDir; 
	
	Double m_dTotalCost;         ///< sum of partition RD costs
	UInt m_uiTotalDistortion; 
	UInt m_uiTotalBits;        ///< sum of partition bits
	UInt m_uiTotalBins;       ///< sum of partition bins 

	UChar*        m_puhChromaIntraDir;  ///< array of intra directions (chroma)
	UChar*        m_puhInterDir;	
	Char*         m_apiMVPIdx[2];       ///< array of motion vector predictor candidates
	Char*         m_apiMVPNum[2];  
};

struct TComYuv
{
  Pel*    m_apiBufY;
  Pel*    m_apiBufU;
  Pel*    m_apiBufV;
  
  // ------------------------------------------------------------------------------------------------------------------
  //  Parameter for general YUV buffer usage
  // ------------------------------------------------------------------------------------------------------------------
  
  UInt     m_iWidth;
  UInt     m_iHeight;
  UInt     m_iCWidth;
  UInt     m_iCHeight;
};
typedef struct TComYuv TComYuv;


struct TComTrQuant
{
  UInt     m_uiMaxTrSize;
  bool     m_bEnc;
  bool     m_useRDOQ;
  bool     m_useRDOQTS;
  bool     m_bUseAdaptQpSelect;
  bool     m_useTransformSkipFast;
  
};
typedef struct TComTrQuant TComTrQuant;

struct TEncSbac
{
	
};
typedef struct TEncSbac TEncSbac;

struct DistParam
{

  //Pel*  pOrg;   //!< 原始图像首地址 
  //Pel*  pCur;    //!< 参考图像首地址 
  //Int   iStrideOrg;   //!< 原始图像跨度  
  //Int   iStrideCur;  //!< 参考图像跨度 
  //Int   iRows;     //!< PU的宽度
  //Int   iCols;   //!< PU的高度
  //Int   iStep;
  //FpDistFunc DistFunc;  //!< 计算失真的函数指针  
  //Int   bitDepth;  //!< 位深
  bool    bApplyWeight;     // whether weithed prediction is used or not
};
typedef struct DistParam DistParam;


struct TEncSearch
{
	UChar*          m_puhQTTempTrIdx;
	UChar*          m_puhQTTempCbf[3];
	UChar*          m_puhQTTempTransformSkipFlag[3];
	
	Int* m_iYuvExtStride;
	Int m_iYuvExtStride;
	Int m_iYuvExtHeight;
	
	TComYuv   m_acYuvPred[2];
	TComYuv   m_cYuvPredTemp;
	
	TEncSbac*** m_pppcRDSbacCoder;
	TEncSbac* m_pcRDGoOnSbacCoder;
	DistParam       m_cDistParam;
	
	UInt  m_auiMVPIdxCost[3][3]; //th array bounds
	
};

typedef struct TEncSearch TEncSearch;

struct TComRdCost 
{
	Double  m_dLambda;
	double m_sqrtLamda;
	UInt  m_uiLambdaMotionSAD;
	TComMv m_mvPredictor;
	UInt   m_uiCost;
	
};
typedef struct TComRdCost TComRdCost;

struct TEncEntropyIf
{
	
};
typedef struct TEncEntropyIf TEncEntropyIf;

struct TEncEntropy
{
	UInt    m_uiBakAbsPartIdx;
	UInt    m_uiBakChromaOffset;
	UInt    m_bakAbsPartIdxCU;
	TEncEntropyIf*      m_pcEntropyCoderIf;
};
typedef struct TEncEntropy TEncEntropy;



struct TEncTop
{
	//TEncSampleAdaptiveOffset m_cEncSAO;                     ///< sample adaptive offset class
	TEncSbac***             m_pppcRDSbacCoder;              ///< temporal storage for RD computation
    TEncSbac                m_cRDGoOnSbacCoder;             ///< going on SBAC model for RD stage
	TComRdCost m_cRdCost;
	TComTrQuant m_cTrQuant;
	TEncEntropy m_cEntropyCoder;
};

typedef struct TEncTop TEncTop;

struct TEncCu
{
	
};
typedef struct TEncCu TEncCu;

enum RefPicList
{
	REF_PIC_LIST_0 = 0,   ///< reference list 0
	REF_PIC_LIST_1 = 1,   ///< reference list 1
	REF_PIC_LIST_X = 100  ///< special mark
};
typedef enum RefPicList RefPicList;

enum PartSize
{
  SIZE_2Nx2N = 0,           ///< symmetric motion partition,  2Nx2N
  SIZE_2NxN,            ///< symmetric motion partition,  2Nx N
  SIZE_Nx2N,            ///< symmetric motion partition,   Nx2N
  SIZE_NxN,             ///< symmetric motion partition,   Nx N
  SIZE_2NxnU,           ///< asymmetric motion partition, 2Nx( N/2) + 2Nx(3N/2)
  SIZE_2NxnD,           ///< asymmetric motion partition, 2Nx(3N/2) + 2Nx( N/2)
  SIZE_nLx2N,           ///< asymmetric motion partition, ( N/2)x2N + (3N/2)x2N
  SIZE_nRx2N,           ///< asymmetric motion partition, (3N/2)x2N + ( N/2)x2N
  SIZE_NONE = 15
};
typedef enum PartSize PartSize;

enum PredMode
{
  MODE_INTER = 0,           ///< inter-prediction mode
  MODE_INTRA = 1,           ///< intra-prediction mode
  MODE_NONE = 15
};
typedef enum PredMode PredMode;

int g_auiZscanToRaster[256] = {0,1,16,17,2,3,18,19,32,33,48,49,34,35,50,51,
                               4,5,20,21,6,7,22,23,36,37,52,53,38,39,54,55,
							   64,65,80,81,66,67,82,83,96,97,112,113,98,99,114,115,
							   68,69,84,85,70,71,86,87,100,101,116,117,102,103,118,119,
							   8,9,24,25,10,11,26,27,40,41,56,57,42,43,58,59,
							   12,13,28,29,14,15,30,31,44,45,60,61,46,47,62,63,
							   72,73,88,89,74,75,90,91,104,105,120,121,106,107,122,123,
							   76,77,92,93,78,79,94,95,108,109,124,125,110,111,126,127,
							   128,129,144,145,130,131,146,147,160,161,176,177,162,163,178,179,
							   132,133,148,149,134,135,150,151,164,165,180,181,166,167,182,183,
							   192,193,208,209,194,195,210,211,224,225,240,241,226,227,242,243,
							   196,197,212,213,198,199,214,215,228,229,244,245,230,231,246,247,
							   136,137,152,153,138,139,154,155,168,169,184,185,170,171,186,187,
							   140,141,156,157,142,143,158,159,172,173,188,189,174,175,190,191,
							   200,201,216,217,202,203,218,219,232,233,248,249,234,235,250,251,
							   204,205,220,221,206,207,222,223,236,237,252,253,238,239,254,255};
							   
int g_auiZscanToRaster[256] = {0,1,16,17,2,3,18,19,32,33,48,49,34,35,50,51,
                               4,5,20,21,6,7,22,23,36,37,52,53,38,39,54,55,
							   64,65,80,81,66,67,82,83,96,97,112,113,98,99,114,115,
							   68,69,84,85,70,71,86,87,100,101,116,117,102,103,118,119,
							   8,9,24,25,10,11,26,27,40,41,56,57,42,43,58,59,
							   12,13,28,29,14,15,30,31,44,45,60,61,46,47,62,63,
							   72,73,88,89,74,75,90,91,104,105,120,121,106,107,122,123,
							   76,77,92,93,78,79,94,95,108,109,124,125,110,111,126,127,
							   128,129,144,145,130,131,146,147,160,161,176,177,162,163,178,179,
							   132,133,148,149,134,135,150,151,164,165,180,181,166,167,182,183,
							   192,193,208,209,194,195,210,211,224,225,240,241,226,227,242,243,
							   196,197,212,213,198,199,214,215,228,229,244,245,230,231,246,247,
							   136,137,152,153,138,139,154,155,168,169,184,185,170,171,186,187,
							   140,141,156,157,142,143,158,159,172,173,188,189,174,175,190,191,
							   200,201,216,217,202,203,218,219,232,233,248,249,234,235,250,251,
							   204,205,220,221,206,207,222,223,236,237,252,253,238,239,254,255};

							   
int g_auiRasterToPelX[256] = {0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
                              0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60};
							   
							   
int g_auiRasterToPelY[256] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                              4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
							  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
							  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
							  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
							  20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
							  24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
							  28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
							  32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
							  36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
							  40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
							  44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,
							  48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
							  52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,
							  56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,
							  60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60};
							  
extern TEncTop* m_pcEncTop;
extern TEncCu* m_pcCuEncoder;
extern TComPic* pcPic;	//将pcPic作为外部变量，只能够实现单帧的区块滤波，若要实现多帧，将pcPic作为输入数据，放入In中，可定位到正确图像
//extern TComPicSym* 	pcPicSym = pcPic->m_apcPicSym;
extern TComPicSym* 	pcPicSym;
extern TComDataCU* pcCU;

extern TEncSbac*** m_pppcRDSbacCoder;
extern TEncSbac* m_pcRDGoOnSbacCoder;

int m_maxCUHeight = 64;
int m_maxCUWidth = 64;
int m_numCTUsPic = 9;

//非8x8块
composite xCheckRDCostMerge(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                          unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostMerge(In)
	{
		UInt uiAbsZorderIdx;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{	
			
		    if(++iCount == numCount)  //uhDepth = 2时，需4个8x8块处理完毕 ；
			{
				//本地创建临时和最佳Yuv
				TComDataCU* rpcTempCU = NULL;
				TComDataCU* rpcBestCU  = NULL;
				
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				
				TComYuv *pcPredYuv = NULL,*pcRecoYuv = NULL, *pcResiYuv = NULL ;  //没有加后缀的都表示临时；最佳的加Best后缀加以区别
				TComYuv *pcPredYuvBest = NULL,*pcRecoYuvBest = NULL, *pcResiYuvBest = NULL;
				
				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int mergeCandBuffer[5];
				Int numValidMergeCand = 0;
				
				UInt ui = 0;
				//UChar uhDepth = 3;  //当前CU的深度，3
				UInt  uiCurrPartNumb = 256>>(2*uhDepth);  //getNumPartitions()
				UInt  uiWidth = 64>>uhDepth;
				UInt  uiHeight = 64>>uhDepth;
				UInt  uiPartAddr = 0;
				
				bool bestIsSkip = false;
				
				UInt iteration = 2;
				UInt uiNoResidual = 0;
				UInt uiMergeCand  = 0;
				
				bool bTransquantBypassFlag = false;
				
				//Int orgQP = rpcTempCU->m_phQP[0];
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟最佳和临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   createCurYuv_cos(pcPredYuvBest,uiWidth,uiHeight);
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   createCurYuv_cos(pcRecoYuvBest,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);   createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
				if(uiAbsZorderIdx == 256)
				{
					uiAbsZorderIdx = 0;
				}					
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				
				for( ui = 0; ui < 5; ++ui )
				{
					uhInterDirNeighbours[ui] = 0;
					mergeCandBuffer[ui] = 0;
				}
				
				memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb ); //SIZE_2Nx2N
				
				getInterMergeCandidates_cos(rpcTempCU,0,0,cMvFieldNeighbours,uhInterDirNeighbours,numValidMergeCand,-1);
				
				for( uiNoResidual = 0; uiNoResidual < iteration; ++uiNoResidual )
				{
					for( uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )    //!< 遍历所有merging candidates
					{
						if(!(uiNoResidual==1 && mergeCandBuffer[uiMergeCand]==1))    //!< uiNoResidual等于0或者mergeCandBuffer[uiMergeCand]等于0时
						{
							if( !(bestIsSkip && uiNoResidual == 0) )     //!< bestIsSkip等于false或者uiNoResidual等于1时条件成立
							{
								bool isZero_QtRootCbfTemp = 0;
								
								// set MC parameters
								memset( rpcTempCU->m_pePredMode,0,uiCurrPartNumb ); // MODE_INTER, interprets depth relative to LCU level
								memset( rpcTempCU->m_CUTransquantBypass,bTransquantBypassFlag,uiCurrPartNumb );
								memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb ); // interprets depth relative to LCU level
								setMergeFlagSubParts_cos(rpcTempCU,true,0,0,uhDepth);// interprets depth relative to LCU level
								setMergeIndexSubParts_cos(rpcTempCU,uiMergeCand, 0, 0, uhDepth ); // interprets depth relative to LCU level
								setInterDirSubParts_cos(rpcTempCU,uhInterDirNeighbours[uiMergeCand], 0, 0, uhDepth ); // interprets depth relative to LCU level
								setAllMvField_cos( rpcTempCU,REF_PIC_LIST_0,cMvFieldNeighbours[0 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
								setAllMvField_cos( rpcTempCU,REF_PIC_LIST_1,cMvFieldNeighbours[1 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
							  
								// do MC
								//m_pcPredSearch->motionCompensation (rpcTempCU, pcPredYuv);   //!< 运动补偿  
								{
									//Int uiWidth  = 64>>uhDepth;
									//Int uiHeight = 64>>uhDepth;
									//UInt uiPartAddr = 0;
									Int  iPartIdx = 0;
									Int  iRefList = 0;
									
									TComYuv* pcMbYuv;
									Int iRefIdx[2] = {-1,-1};
									for(iPartIdx = 0; iPartIdx < 1; iPartIdx++)
									{
										//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
										//xPredInterBi(rpcTempCU, uiPartAddr, uiWidth, uiHeight, pcPredYuv);  //执行代码如下
										for (iRefList = 0; iRefList < 2; iRefList++ )
										{
											RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
											//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
											//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
											iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
											if ( iRefIdx[iRefList] < 0 )
											{
												continue;
											}

											//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

											pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
											//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
											if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, true );
											}
											else
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, false );
											}
										}
										
										//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, uiWidth, uiHeight, pcPredYuv );
										{
											TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
											TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
											if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
											{
												//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
												addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
											}
											else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
											{
												//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );
																
												
																
												copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
											else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
											{
												//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );
												
																
												copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
																
										}
									} 
								}
							  
								// estimate residual and encode everything
								//m_pcPredSearch->encodeResAndCalcRdInterCU(rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));          //!< 对残差进行编码并计算RDCost</p><p>  
								encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));
							  
								isZero_QtRootCbfTemp = isZeroQtRootCbf_cos(rpcTempCU);  //判断 rpcTempCU->getQtRootCbf(0) == 0 的逻辑真假
								
								if ( uiNoResidual == 0 && isZero_QtRootCbfTemp )          //!< CBF为0，说明变换系数全为0  
								{
									// If no residual when allowing for one, then set mark to not try case where residual is forced to 0
									mergeCandBuffer[uiMergeCand] = 1;
								}
							  
								//rpcTempCU->setSkipFlagSubParts( isZero_QtRootCbfTemp, 0, uhDepth );
								memset(rpcTempCU->m_skipFlag,isZero_QtRootCbfTemp,uiCurrPartNumb);
								
								//xCheckDQP( rpcTempCU );
								//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth);           //!< 更新最佳模式  
								if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
								{
									TComYuv* pcYuv;
									// Change Information data
									TComDataCU* pcCU = rpcBestCU;
									rpcBestCU = rpcTempCU;
									rpcTempCU = pcCU;

									// Change Prediction data
									pcYuv = pcPredYuvBest;
									pcPredYuvBest = pcPredYuv;
									pcPredYuv = pcYuv;

									// Change Reconstruction data
									pcYuv = pcRecoYuvBest;
									pcRecoYuvBest = pcRecoYuv;
									pcRecoYuv = pcYuv;

									pcYuv = NULL;
									pcCU  = NULL;

									// store temp best CI for next CU coding
									//m_pppcRDSbacCoder[uhDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);	
								}
								
								//rpcTempCU->initEstData( uhDepth, orgQP, bTransquantBypassFlag );     //!< 重新初始化预测参数，为下一次预测做准备
								initEstData_cos(rpcTempCU,uhDepth, rpcTempCU->m_phQP[0], bTransquantBypassFlag);
								if( !bestIsSkip )
								{
									bestIsSkip = isZeroQtRootCbf_cos(rpcBestCU); //rpcBestCU->getQtRootCbf(0) == 0;
								}
							}
						}
					}	
				}
				
				//到此Merge模式的最佳CU状态已保存至rpcBestCU，最佳YUV已保存至pcPredYuvBest，临时CU和Yuv空间可以删除了
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuv);
				destoryCurYuv_cos(pcRecoYuv); //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurYuv_cos(pcResiYuv);
					
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcBestCU;
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuvBest;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuvBest;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuvBest;
				
				///////////////////////////////////
				//m_pppcRDSbacCoder[uhNextDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]);
				//////////////////////////////////
				  
					//由于我们是采用split的方式进行8x8块的两种模式，合并之后进行两次编码比较(在encodeRelated_8x8中)，在这里各自修复熵编码器的上下文等到join之后的encodeRelated_8x8中，其实只有一次即encodeRelated_8x8中for循环的第一次得到了修复
					//因此，这里修复没有作用
					//----- restore context models -----
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
			
				iCount = 0;
			}
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};	
}


composite xCheckRDCostInter(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter(In)
	{
		int iCount;
		int numCount;
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComDataCU *rpcTempCU = NULL;
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
				TComYuv* pcResiYuvBest = NULL;
				
				
				//UChar uhDepth        = 3;  //当前CU的深度，3
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				UInt  uiWidth = 64>>uhDepth;
				UInt  uiHeight = 64>>uhDepth;
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
				
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
				if(uiAbsZorderIdx == 256)
				{
					uiAbsZorderIdx = 0;
				}					
				
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 0, uiCurrPartNumb); // SIZE_2Nx2N
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER
					
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 1;
					Int           iNumPredDir = 1;
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = 64>>uhDepth;
					Int			  iRoiHeight = 64>>uhDepth;
				  
					UInt          uiMbBits[3] = {1, 3, 5};
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_2Nx2N;
					PartSize      SIZE_2Nx2N = SIZE_2Nx2N;
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					//for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_2Nx2N,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
												
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostInter_Nx2N(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                 input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_Nx2N(In)
	{
		UInt uiAbsZorderIdx;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComDataCU *rpcTempCU = NULL;
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
				TComYuv* pcResiYuvBest = NULL;
				
				//UChar uhDepth        = 3;  //当前CU的深度，0
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				UInt  uiWidth = 64>>uhDepth;
				UInt  uiHeight = 64>>uhDepth;
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
				
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 2, uiCurrPartNumb); // SIZE_Nx2N
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER
					
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，Nx2N模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = 64>>uhDepth>>1;
					Int			  iRoiHeight = 64>>uhDepth;
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_Nx2N;  //
					PartSize      SIZE_Nx2N = SIZE_Nx2N;  //
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 2);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_Nx2N,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							}
						}
						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostInter_2NxN(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                 input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_2NxN(In)
	{
		UInt uiAbsZorderIdx;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComDataCU *rpcTempCU = NULL;
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
				TComYuv* pcResiYuvBest = NULL;
				
				//UChar uhDepth        = 3;  //当前CU的深度，3
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				UInt  uiWidth = 64>>uhDepth;
				UInt  uiHeight = 64>>uhDepth;
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uiDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
				
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 1, uiCurrPartNumb); //SIZE_2NxN
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER
					
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，2NxN模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = 64>>uhDepth;   //2NxN模式的子块宽
					Int			  iRoiHeight = 64>>uhDepth>>1;     //2NxN模式的子块高
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_2NxN;  //
					PartSize      SIZE_2NxN = SIZE_2NxN;
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 1);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_2NxN,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							}
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostInter_2NxnU(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_2NxnU(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				TComDataCU* rpcTempCU = NULL;  //临时开辟
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL,*pcResiYuvBest = NULL;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
				
				
				//UChar uhDepth        = 2;  //当前CU的深度，0
				UInt  uiWidth        = 64>>uhDepth;
				UInt  uiHeight       = 64>>uhDepth;
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
					
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
			
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 4, uiCurrPartNumb); //SIZE_2NxnU = 4;
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，2NxnU模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
					Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_2NxnU;  //
					PartSize      SIZE_2NxnU = SIZE_2NxnU;
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						//iRoiWidth     = getWidth(0);  //宽度不变
						iRoiHeight    = ( iPartIdx == 0 ) ? (uiHeight>>2): (uiHeight >> 2)+(uiHeight >> 1);
						uiPartAddr    = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb>>3);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_2NxnU,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + (((m_pcRdCost->m_uiCost) * uiMEBits) >> 16);
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							}
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
									
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
												
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_2NxnD(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_2NxnD(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				TComDataCU* rpcTempCU = NULL;  //临时开辟
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL,*pcResiYuvBest = NULL;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
				
				
				//UChar uhDepth        = 2;  //当前CU的深度，0
				UInt  uiWidth        = 64>>uhDepth;
				UInt  uiHeight       = 64>>uhDepth;
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
					
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 5, uiCurrPartNumb); //SIZE_2NxnD =5;
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，2NxnU模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
					Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_2NxnD;  //
					PartSize      SIZE_2NxnD = SIZE_2NxnD; 
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						//iRoiWidth     = getWidth(0);  //宽度不变  
						//2016_4_26改正
		
						iRoiHeight = (iPartIdx == 0) ? (uiHeight >> 2) + (uiHeight >> 1) : (uiHeight >> 2);
						uiPartAddr = (iPartIdx == 0) ? 0 : (uiCurrPartNumb >> 3) + (uiCurrPartNumb >> 1);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_2NxnD,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							}
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_nLx2N(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_nLx2N(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				TComDataCU* rpcTempCU = NULL;  //临时开辟
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL,*pcResiYuvBest = NULL;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
				
				
				//UChar uhDepth        = 2;  //当前CU的深度，2
				UInt  uiWidth        = 64>>uhDepth;
				UInt  uiHeight       = 64>>uhDepth;
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
					
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 6, uiCurrPartNumb); // SIZE_nLx2N = 6
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，2NxnU模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
					Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_nLx2N;  //
					PartSize      SIZE_nLx2N = SIZE_nLx2N;  //
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						//iRoiWidth     = getWidth(0);  //高度不变
						iRoiWidth    = ( iPartIdx == 0 ) ?  ( uiWidth >> 2 ) : ( uiWidth >> 1 ) +(uiWidth >> 2);
						uiPartAddr    = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb >> 4);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 )
							  {
								   uiBitsTemp--;
							  }								 
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
							//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_nLx2N,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						 
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							}
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
												
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_nRx2N(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_nRx2N(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		int iCount;
		int numCount;
		init
		{
			uiAbsZorderIdx = 0;
			iCount = 0;
			if(uhDepth == 2)
			{
				numCount = 4;
			}
			if(uhDepth == 1)
			{
				numCount = 128;
			}
			if(uhDepth == 0)
			{
				numCount = 4096;
			}
		}
		work
		{
			if(++iCount == numCount)
			{
				TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
				TComDataCU* rpcTempCU = NULL;  //临时开辟
				TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL,*pcResiYuvBest = NULL;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
				
				
				//UChar uhDepth        = 2;  //当前CU的深度，0
				UInt  uiWidth        = 64>>uhDepth;
				UInt  uiHeight       = 64>>uhDepth;
				UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
				
				
				//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
				//TEncSbac*** m_pppcRDSbacCoder;
				
				//定义TcomTrQuant类型变量
				TComTrQuant m_cTrQuant;
				TComTrQuant* m_pcTrQuant = &m_cTrQuant;
				
				//定义TEncSearch类型变量
				TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
				TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				
				double dRdCost = 0.0;
				RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
				RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
				
				//开辟临时的CU和YUV
				createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
					
				createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
				createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
				createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
				
				uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256) 
				{
					uiAbsZorderIdx = 0;
				}
				
				//m_cTrQuant.init(32,true,true,true,true,0);
				m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
				m_pcTrQuant->m_useRDOQ = true;
				m_pcTrQuant->m_useRDOQTS = true;
				m_pcTrQuant->m_bEnc = true;
				m_pcTrQuant->m_useTransformSkipFast = true;
				m_pcTrQuant->m_bUseAdaptQpSelect = false;
				
				//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
				initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
				
				//rpcTempCU->setDepthSubParts( uhDepth, 0 );
				//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
				//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
				//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
				
				memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
				memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
				memset( rpcTempCU->m_pePartSize, 7 , uiCurrPartNumb); //SIZE_nRx2N = 7
				memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
				//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
				{
					TComMv        cMvSrchRngLT;
					TComMv        cMvSrchRngRB;
				  
					TComMv        cMvZero;
					TComMv        TempMv; //kolya
	  
					TComMv        cMv[2];
					TComMv        cMvBi[2];
					TComMv        cMvTemp[2][33];
	  
					Int           iNumPart    = 2;  //划分为2个，2NxnU模式
					Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
	  
					TComMv        cMvPred[2][33];
				  
					TComMv        cMvPredBi[2][33];
					Int           aaiMvpIdxBi[2][33];
				  
					Int           aaiMvpIdx[2][33];
					Int           aaiMvpNum[2][33];
				  
					AMVPInfo aacAMVPInfo[2][33];
				  
					Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
					Int           iRefIdxBi[2];
				  
					UInt          uiPartAddr = 0;
					Int           iRoiWidth = uiWidth;   //2NxN模式的子块宽
					Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
				  
					UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
				  
					UInt          uiLastMode = 0;
					Int           iRefStart, iRefEnd;
				  
					//PartSize      ePartSize = SIZE_nRx2N;  //
					PartSize      SIZE_nRx2N = SIZE_nRx2N;
					Int           bestBiPRefIdxL1 = 0;
					Int           bestBiPMvpL1 = 0;
					UInt          biPDistTemp = MAX_INT;


					TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
					UChar uhInterDirNeighbours[5];
					Int numValidMergeCand = 0 ;
					Int iPartIdx = 0;
					
					//Yuv空间的清理
					predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
					
					for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
					{
						UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
						UInt          uiCostBi  =   MAX_UINT;
						UInt          uiCostTemp;
		
						UInt          uiBits[3];
						UInt          uiBitsTemp;

						UInt          bestBiPDist = MAX_INT;

						UInt          uiCostTempL0[16];
						Int iNumRef = 0;
						Int iRefList = 0;
						Int iRefIdxTemp = 0;
						
						UInt          uiBitsTempL0[16];

						TComMv        mvValidList1;
						Int           refIdxValidList1 = 0;
						UInt          bitsValidList1 = MAX_UINT;
						UInt          costValidList1 = MAX_UINT;
						
						
						UInt uiMEBits = 0;
						
						for (iNumRef=0; iNumRef < 16; iNumRef++)
						{
							uiCostTempL0[iNumRef] = MAX_UINT;
						}
						
						//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
		
						//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
						//iRoiHeight   =  getHeight(0);  //高度不变
						
						iRoiWidth     = ( iPartIdx == 0 ) ? (uiWidth >> 2) + (uiWidth >> 1) : ( uiWidth >> 2 );
						uiPartAddr = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb >> 2) + (uiCurrPartNumb >> 4);
		
						//  Uni-directional prediction
						for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
						{
						  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
						  {
							uiBitsTemp = uiMbBits[iRefList];
							if ( numRefIdx > 1 )
							{
							  uiBitsTemp += iRefIdxTemp+1;
							  if ( iRefIdxTemp == numRefIdx-1 ) 
							  {
								  uiBitsTemp--;
							  }
							}

							//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
							
							aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
							aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

							uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
					
							xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
						
							copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
							
							checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
							//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
							//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

							if ( iRefList == 0 )
							{
							  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
							  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
							}
							if ( uiCostTemp < uiCost[iRefList] )
							{
							  uiCost[iRefList] = uiCostTemp;
							  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

							  // set motion
							  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							  iRefIdx[iRefList] = iRefIdxTemp;
							}

						  }
						}
		
						//  Clear Motion Field
						clearMvField_cos(rpcTempCU,SIZE_nRx2N,uiPartAddr,iPartIdx);
						
						
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
						
						
						// Set Motion Field_
						cMv[1] = mvValidList1;
						iRefIdx[1] = refIdxValidList1;
						uiBits[1] = bitsValidList1;
						uiCost[1] = costValidList1;

						if ( uiCost[0] <= uiCost[1] )
						{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
						}

						//当划分size不等于2Nx2N模式时
						{
							UInt uiMRGInterDir = 0;     
							TComMvField cMRGMvField[2];
							UInt uiMRGIndex = 0;

							UInt uiMEInterDir = 0;
							TComMvField cMEMvField[2];
							 
							// calculate ME cost
							UInt uiMEError = MAX_UINT;
							UInt uiMECost = 0;
							// find Merge result
							UInt uiMRGCost = MAX_UINT;
							
							m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
							xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
							uiMECost = uiMEError + (((m_pcRdCost->m_uiCost) * uiMEBits) >> 16);
							 // save ME result.
							uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
							getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

							
							xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
							
							if ( uiMRGCost < uiMECost )
							{
								// set Merge result
							
								setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
								setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
								
								
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							
							}
							else
							{
								// set ME result
								
								setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
								setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							}
						}

						//  MC
						//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
						{
							//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
							
							Int  iRefList = 0;
									
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
									
							//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
										
							//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
										
							//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
							{
								TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
								TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
								if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
								{
									//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
									addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								}
								else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
								{
									//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
									
													
									copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
								else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
								{
									//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
													
												
									copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
									copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								}
													
							}
						}
		
					} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
					
					(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
				}
				
				
				
				//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
				encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
				
				//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
				dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcTempCU->m_dTotalCost = dRdCost;
				
				//xCheckDQP( rpcTempCU );
				//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
				
				//删除相应空间
				destoryCuYuv_cos(pcResiYuvBest);
				
				Out[0].ulpcBestCU = In[0].ulpcBestCU;
				Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
				Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
				Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
				Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
				
				Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
				Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
				Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
				Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
				
				////////////////////////////////////熵编码器状态加载
				//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
				////////////////////////////////////
				
					  
					//----- restore context models -----//道理同上
					//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
				iCount = 0;
			}
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostMerge_8x8(output stream<unsigned long ulpcTempCU,unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostMerge_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{	
			//本地创建临时和最佳Yuv
			TComDataCU* rpcTempCU = NULL;
			TComDataCU* rpcBestCU  = NULL;
			
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL,*pcRecoYuv = NULL, *pcResiYuv = NULL ;  //没有加后缀的都表示临时；最佳的加Best后缀加以区别
			TComYuv *pcPredYuvBest = NULL,*pcRecoYuvBest = NULL, *pcResiYuvBest = NULL;
			
			TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
			UChar uhInterDirNeighbours[5];
			Int mergeCandBuffer[5];
			Int numValidMergeCand = 0;
			
			UInt ui = 0;
			//UChar uhDepth = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(2*uhDepth);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			UInt  uiPartAddr = 0;
			
			bool bestIsSkip = false;
			
			UInt iteration = 2;
			UInt uiNoResidual = 0;
			UInt uiMergeCand  = 0;
			
			bool bTransquantBypassFlag = false;
			
			//Int orgQP = rpcTempCU->m_phQP[0];
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;  //需要设置dLambda等，m_pcTrQuant->setLambdas( lambdaArray );
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;   
			TComRdCost* m_pcRdCost = &m_cRdCost; //需要设置dLambda等，m_pcRdcost->setLamda(dLambda);
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟最佳和临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   createCurYuv_cos(pcPredYuvBest,uiWidth,uiHeight);
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   createCurYuv_cos(pcRecoYuvBest,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);   createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) 
			{
				uiAbsZorderIdx = 0;
			}
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			
			for( ui = 0; ui < 5; ++ui )
			{
				uhInterDirNeighbours[ui] = 0;
				mergeCandBuffer[ui] = 0;
			}
			
			memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb );  // SIZE_2Nx2N
			
			getInterMergeCandidates_cos(rpcTempCU,0,0,cMvFieldNeighbours,uhInterDirNeighbours,numValidMergeCand,-1);
			
			for( uiNoResidual = 0; uiNoResidual < iteration; ++uiNoResidual )
			{
				for( uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )    //!< 遍历所有merging candidates
				{
					if(!(uiNoResidual==1 && mergeCandBuffer[uiMergeCand]==1))    //!< uiNoResidual等于0或者mergeCandBuffer[uiMergeCand]等于0时
					{
						if( !(bestIsSkip && uiNoResidual == 0) )     //!< bestIsSkip等于false或者uiNoResidual等于1时条件成立
						{
							bool isZero_QtRootCbfTemp = 0;
							
							// set MC parameters
							memset( rpcTempCU->m_pePredMode,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							memset( rpcTempCU->m_CUTransquantBypass,bTransquantBypassFlag,uiCurrPartNumb );
							memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							setMergeFlagSubParts_cos(rpcTempCU,true,0,0,uhDepth);// interprets depth relative to LCU level
							setMergeIndexSubParts_cos(rpcTempCU,uiMergeCand, 0, 0, uhDepth ); // interprets depth relative to LCU level
							setInterDirSubParts_cos(rpcTempCU,uhInterDirNeighbours[uiMergeCand], 0, 0, uhDepth ); // interprets depth relative to LCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_0,cMvFieldNeighbours[0 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_1,cMvFieldNeighbours[1 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
						   
							// do MC
							//m_pcPredSearch->motionCompensation (rpcTempCU, pcPredYuv);   //!< 运动补偿  
							{
								//Int uiWidth  = 64>>uhDepth;
								//Int uiHeight = 64>>uhDepth;
								//UInt uiPartAddr = 0;
								Int  iPartIdx = 0;
								Int  iRefList = 0;
								
								TComYuv* pcMbYuv;
								Int iRefIdx[2] = {-1,-1};
								for(iPartIdx = 0; iPartIdx < 1; iPartIdx++)
								{
									//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
								    
								    //xPredInterBi(rpcTempCU, uiPartAddr, uiWidth, uiHeight, pcPredYuv);  //执行代码如下
									for (iRefList = 0; iRefList < 2; iRefList++ )
									{
										
										RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
										//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
										//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
										//TComCUMvField *test = &(rpcTempCU->m_acCUMvField[eRefPicList]);
										//iRefIdx[iRefList] = test->m_piRefIdx[uiPartAddr];
										iRefIdx[iRefList] = rpcTempCU->m_acCUMvField[eRefPicList].m_piRefIdx[0];
										if ( iRefIdx[iRefList] < 0 )
										{
											continue;
										}
										
										
										pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
										//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
										if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
										{
											xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, true );
										}
										else
										{
											xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, false );
										}
									}
									
									//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, uiWidth, uiHeight, pcPredYuv );
									{
										TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
										TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
										if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
										{
											//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
											addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
										}
										else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
										{
											//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );
												
											
											//pcYuvSrc0->copyPartToPartLuma  (pcPredYuv, uiPartAddr, uiWidth, uiHeight);
											//pcYuvSrc0->copyPartToPartChroma(pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											
												
											copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
											copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
										}
										else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
										{
											//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );
												
											
											//pcYuvSrc1->copyPartToPartLuma  (pcPredYuv, uiPartAddr, uiWidth, uiHeight);
											//pcYuvSrc1->copyPartToPartChroma(pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											
												
											copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
											copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
										}
												
									}
								} 
							}      
						  
							// estimate residual and encode everything
							//m_pcPredSearch->encodeResAndCalcRdInterCU(rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));          //!< 对残差进行编码并计算RDCost</p><p>  
							encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));
						  
							isZero_QtRootCbfTemp = isZeroQtRootCbf_cos(rpcTempCU);  //判断 rpcTempCU->getQtRootCbf(0) == 0 的逻辑真假
							
							if ( uiNoResidual == 0 && isZero_QtRootCbfTemp )          //!< CBF为0，说明变换系数全为0  
							{
								// If no residual when allowing for one, then set mark to not try case where residual is forced to 0
								mergeCandBuffer[uiMergeCand] = 1;
							}
						  
							//rpcTempCU->setSkipFlagSubParts( isZero_QtRootCbfTemp, 0, uhDepth );
							memset(rpcTempCU->m_skipFlag,isZero_QtRootCbfTemp,uiCurrPartNumb);
							
							//xCheckDQP( rpcTempCU );
							//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth);           //!< 更新最佳模式  
							if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
							{
								TComYuv* pcYuv;
								// Change Information data
								TComDataCU* pcCU = rpcBestCU;
								rpcBestCU = rpcTempCU;
								rpcTempCU = pcCU;

								// Change Prediction data
								pcYuv = pcPredYuvBest;
								pcPredYuvBest = pcPredYuv;
								pcPredYuv = pcYuv;

								// Change Reconstruction data
								pcYuv = pcRecoYuvBest;
								pcRecoYuvBest = pcRecoYuv;
								pcRecoYuv = pcYuv;

								pcYuv = NULL;
								pcCU  = NULL;

								// store temp best CI for next CU coding
								//m_pppcRDSbacCoder[uhDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);	
							}
							
							//rpcTempCU->initEstData( uhDepth, orgQP, bTransquantBypassFlag );     //!< 重新初始化预测参数，为下一次预测做准备
							initEstData_cos(rpcTempCU,uhDepth, rpcTempCU->m_phQP[0], bTransquantBypassFlag);
							if( !bestIsSkip )
							{
								bestIsSkip = isZeroQtRootCbf_cos(rpcBestCU); //rpcBestCU->getQtRootCbf(0) == 0;
							}
						}
					}
				}	
			}
			
		
			//到此Merge模式的最佳CU状态已保存至rpcBestCU，最佳YUV已保存至pcPredYuvBest，临时CU和Yuv空间可以删除了,但是原始Yuv的数据还不能删除
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuv);
			destoryCurYuv_cos(pcRecoYuv); //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurYuv_cos(pcResiYuv);
			
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuvBest;
			///////////////////////////////////
			//m_pppcRDSbacCoder[uhNextDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]);
			//////////////////////////////////
			  
				//由于我们是采用split的方式进行8x8块的两种模式，合并之后进行两次编码比较(在encodeRelated_8x8中)，在这里各自修复熵编码器的上下文等到join之后的encodeRelated_8x8中，其实只有一次即encodeRelated_8x8中for循环的第一次得到了修复
				//因此，这里修复没有作用
				//----- restore context models -----
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};	
}
	
composite xCheckRDCostInter_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			
			//UChar uhDepth        = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) 
			{
				uiAbsZorderIdx = 0;
			}
			
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 0, uiCurrPartNumb); //SIZE_2Nx2N
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				//TComMv        cMvSrchRngLT;
				//TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 1;
				Int           iNumPredDir = 1;
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3] = {1, 3, 5};
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize   ePartSize = SIZE_2Nx2N;
				PartSize   SIZE_2Nx2N = SIZE_2Nx2N;

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				//for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
    
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) 
						  {
							  uiBitsTemp--;
						  }
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
					
						//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}

					  }
					}
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2Nx2N,uiPartAddr,iPartIdx);
					
					//rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					
					//rpcTempCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if ( uiCost[0] <= uiCost[1] )
					{
					  uiLastMode = 0;
					  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
					  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
					  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
					  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  uiMEBits = uiBits[0];
					   
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
					  //rpcTempCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(0) );
					  
					 
					  //rpcTempCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
					  //rpcTempCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
					  //uiMEBits = uiBits[0];
					  
					}

					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
						
						Int  iRefList = 0;
								
						TComYuv* pcMbYuv;
						Int iRefIdx[2] = {-1,-1};
								
						//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
								    
						//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
						for (iRefList = 0; iRefList < 2; iRefList++ )
						{
							RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
							//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
							//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
							iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
							if ( iRefIdx[iRefList] < 0 )
							{
								continue;
							}

							//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

							pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
							//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
							if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
							}
							else
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
							}
						}
									
						//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						{
							TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
							TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
							if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
							{
								//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
							}
							else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
							{
								//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
								//pcYuvSrc0->copyPartToPartLuma  (pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								//pcYuvSrc0->copyPartToPartChroma(pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								
												
								copyPartToPartLuma_cos  (pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
							else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
							{
								//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
								//pcYuvSrc1->copyPartToPartLuma  (pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								//pcYuvSrc1->copyPartToPartChroma(pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								
												
								copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
												
						}
					}
    
				}//  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_Nx2N_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                      input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_Nx2N_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，0
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) 
			{
				uiAbsZorderIdx = 0;
			}
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 2, uiCurrPartNumb);  //SIZE_Nx2N = 2
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，Nx2N模式
				Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth>>1;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_Nx2N;  //
				PartSize      SIZE_Nx2N = SIZE_Nx2N;  
				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
    
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 2);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) 
						  {
							  uiBitsTemp--;
						  }
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
					
						//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}

					  }
					}
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_Nx2N,uiPartAddr,iPartIdx);
					
					//rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_1)->setAllMvField( TComMvField(), ePartSize, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
					//rpcTempCU->getCUMvField(REF_PIC_LIST_1)->setAllMvd    ( cMvZero,       ePartSize, uiPartAddr, 0, iPartIdx );
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					
					//rpcTempCU->setMVPIdxSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPNumSubParts( -1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPIdxSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					//rpcTempCU->setMVPNumSubParts( -1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
	
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if ( uiCost[0] <= uiCost[1] )
					{
					  uiLastMode = 0;
					  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
					  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
					  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
					  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  uiMEBits = uiBits[0];
					   
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMv( cMv[0], ePartSize, uiPartAddr, 0, iPartIdx );
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllRefIdx( iRefIdx[0], ePartSize, uiPartAddr, 0, iPartIdx );
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  //rpcTempCU->getCUMvField(REF_PIC_LIST_0)->setAllMvd    ( TempMv,                 ePartSize, uiPartAddr, 0, iPartIdx );
					  //rpcTempCU->setInterDirSubParts( 1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(0) );
					  
					 
					  //rpcTempCU->setMVPIdxSubParts( aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
					  //rpcTempCU->setMVPNumSubParts( aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
					  //uiMEBits = uiBits[0];
					  
					}
					
					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + (((m_pcRdCost->m_uiCost) * uiMEBits) >> 16);
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
						
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						}
					}

					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
						
						Int  iRefList = 0;
								
						TComYuv* pcMbYuv;
						Int iRefIdx[2] = {-1,-1};
								
						//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
								    
						//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
						for (iRefList = 0; iRefList < 2; iRefList++ )
						{
							RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
							//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
							//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
							iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
							if ( iRefIdx[iRefList] < 0 )
							{
								continue;
							}

							//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

							pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
							//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
							if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
							}
							else
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
							}
						}
									
						xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						{
							TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
							TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
							if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
							{
								//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
							}
							else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
							{
								//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
								//pcYuvSrc0->copyPartToPartLuma  (pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								//pcYuvSrc0->copyPartToPartChroma(pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
								
												
								copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
							else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
							{
								//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
								//pcYuvSrc1->copyPartToPartLuma  (pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								//pcYuvSrc1->copyPartToPartChroma(pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
												
								copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
												
						}
					}
    
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostInter_2NxN_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                      input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_2NxN_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uiDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) 
			{
				uiAbsZorderIdx = 0;
			}
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 1, uiCurrPartNumb);  // SIZE_2NxN = 1
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb ); //MODE_INTER = 0
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxN模式
				Int           iNumPredDir = 1;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;   //2NxN模式的子块宽
				Int			  iRoiHeight = 64>>uhDepth>>1;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3] = {3,0,0};  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2NxN;  //
				PartSize      SIZE_2NxN = SIZE_2NxN;  //
				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < 2; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
    
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 1);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) 
						  {
							  uiBitsTemp--;
						  }
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
					
						//copyAMVPInfo_cos(m_pcPredSearch, rpcTempCU, &aacAMVPInfo[iRefList][iRefIdxTemp]);
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}

					  }
					}
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2NxN,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if ( uiCost[0] <= uiCost[1] )
					{
					  uiLastMode = 0;
					  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
					  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  uiMEBits = uiBits[0];
					 
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + (((m_pcRdCost->m_uiCost) * uiMEBits) >> 16);
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
						
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						}
					}

					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						//xPredInterBi  (pcCU, uiPartAddr, iWidth, iHeight, pcYuvPred );
						
						Int  iRefList = 0;
								
						TComYuv* pcMbYuv;
						Int iRefIdx[2] = {-1,-1};
								
						//if(xCheckIdenticalMotion( rpcTempCU, uiPartAddr ))  {....}   //P帧恒为假
								    
						//xPredInterBi(rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv);  //执行代码如下
						for (iRefList = 0; iRefList < 2; iRefList++ )
						{
							RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
							//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
							//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
							iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
							if ( iRefIdx[iRefList] < 0 )
							{
								continue;
							}

							//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

							pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
							//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
							if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
							}
							else
							{
								xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
							}
						}
									
						//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						{
							TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
							TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
							if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
							{
								//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
								addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, iRoiWidth, iRoiHeight);
							}
							else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
							{
								//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
												
								copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
							else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
							{
								//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight );
												
								
												
								copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth, iRoiHeight);
								copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, iRoiWidth>>1, iRoiHeight>>1);
							}
												
						}
					}
    
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite encodeRelated_8x8(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
							 input stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>In)
{
	Out = encodeRelated_8x8(In)
	{
		int uiPartUnitIdx;  //记录处理的个数
		init
		{
			uiPartUnitIdx = 0;
		}
		work
		{
			
			UInt uiDepth = 3; //rpcTempCU_F-> m_puhDepth[0];  
			double dRdCost = 0.0;
			int i = 0;
			TComDataCU *rpcBestCU = (TComDataCU *)(In[0].ulpcTempCU);  //从Merge处的分支的输入得来的最佳
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv);  
			TComYuv *pcPredYuvBest = (TComYuv *)(In[0].ulpcPredYuv);  //从Merge处的分支得来的最佳
			TComYuv *pcRecoYuvBest = (TComYuv *)(In[0].ulpcRecoYuv);
			TComYuv *pcResiYuvBest = (TComYuv *)(In[0].ulpcResiYuv);
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			//initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&(m_pcEncTop->m_cEntropyCoder),m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			for(i = 1; i < 4; i++)
			{
				TComDataCU* rpcTempCU = (TComDataCU *)(In[i].ulpcTempCU);
				TComYuv *pcPredYuvTemp = (TComYuv *)(In[i].ulpcPredYuv);
				TComYuv *pcRecoYuvTemp = (TComYuv *)(In[i].ulpcRecoYuv);
				TComYuv *pcResiYuvTemp = (TComYuv *)(In[i].ulpcResiYuv);
				
				
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
					
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp); //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurYuv_cos(pcResiYuvTemp);
			}
			//原始Yuv删除
			destoryCuYuv_cos(pcOrigYuv);
			
			//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
			
			//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
			if(++uiPartUnitIdx == 4)  
			{
				//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
				uiPartUnitIdx = 0;
			}
			
			resetBits_cos();
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;
				
			copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

			xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth,pcRecoYuvBest);    //至此，一个8x8块的计算全部完成
			
			Out[0].ulpcBestCU = (unsigned long)rpcBestCU;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
		}
		window
		{
			In sliding(4,4);   //输入为join合并的4种模式的临时CU
			Out tumbling(1);  //输出一个最佳的8x8块
		}
	};
}


composite xCheckRDCostInter8x8_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                                    input stream<unsigned long ulpcOrigYuv>In)
{	
	stream<unsigned long ulpcTempCU,unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>OO7;
	
	OO7 = splitjoin(In)
	{
		int i;
		UChar uhDepth = 3;
		split duplicate(1);
		for(i=0; i<4; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge_8x8(uhDepth);  //8x8块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter_8x8(uhDepth);  //8x8块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N_8x8(uhDepth);  //8x8块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN_8x8(uhDepth);  //8x8块的2N*N模式
		}	
		join roundrobin(1);		
	};
	Out = encodeRelated_8x8(OO7)();  //输出一个最佳的8x8块
}


//将某一8*8最终的CU状态及YUV拷贝至上一层16*16 CU的相应位置,也即16*16的分割模式
composite copyPartTo_16x16(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_16x16(In)
	{
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_16x16;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 2;
			uhWidth  = 16;
			uhHeight = 16;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_16x16 = NULL;  //
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
	        //pcCU为LCU的指针
			
			TComPic* pcPic = pcCU->m_pcPic;
			TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			
			int y;
			Pel* pDst, *pDstU, *pDstV;
			Pel* pSrc, *pSrcU, *pSrcV;
			UInt iDstStride, iSrcStride,iWidth,iCWidth;
			
			
			UInt iCuAddr = pcCU->m_uiCUAddr;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;  //熵编码器的指针还未指定，待添加
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0; 
			
			//从 encodeRelated_8x8 的输出得到的最佳块的信息;待完成
			TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);
			TComYuv *pcPredYuvBest_8x8 = (TComYuv *)(In[0].ulpcPredYuvBest);
			TComYuv *pcRecoYuvBest_8x8 = (TComYuv *)(In[0].ulpcRecoYuvBest); 
			TComYuv *pcResiYuvBest_8x8 = (TComYuv *)(In[0].ulpcResiYuvBest);  //根据输入完成
			
			if(uiPartUnitIdx == 0)  //说明是在处理一个新的16x16块
			{	
				createCurCU_cos(pcCU,rpcBestCU_16x16,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcOrigYuv,16,16);  //创建原始YUV空间并初始化，注意释放空间
				
				
				createCurYuv_cos(pcPredYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
				
				createCurYuv_cos(pcRecoYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
		
				createCurYuv_cos(pcResiYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
				//pcOrigYuv 原始yuv数据拷贝
				//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
			    {
					int  y;
					short* pDst  = pcOrigYuv->m_apiBufY; 
					short* pDstU = pcOrigYuv->m_apiBufU;
					short* pDstV = pcOrigYuv->m_apiBufV;
					//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
					Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					
					//copyFromPicLuma
					UInt  iDstStride  =  pcOrigYuv->m_iWidth;
					UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
					UInt  iWidth = pcOrigYuv->m_iWidth;
					UInt  iCWidth = pcOrigYuv->m_iCWidth;
					for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
					{
						memcpy( pDst, pSrc, sizeof(short)*iWidth);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					//copyFromPicChroma
					iDstStride = pcOrigYuv->m_iCWidth;
					iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
					for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					} 				
				}
				
				uiAbsZorderIdx += 16;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256)
				{
					uiAbsZorderIdx = 0;
				}					
			}
			
			//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
			//rpcBestCU_16x16->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
			copyPartFrom_cos(rpcBestCU_16x16,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
			
			//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
			{
				
				//计算第uiPartUnitIdx个8x8子块在16x16块中对应位置
				UInt uiDstPartIdx = 4*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
				
				pSrc  = pcRecoYuvBest_8x8->m_apiBufY;
				pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
				
				pSrcU = pcRecoYuvBest_8x8->m_apiBufU;
				pSrcV = pcRecoYuvBest_8x8->m_apiBufV;
				pDstU =     pcRecoYuvBest->m_apiBufU + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
				pDstV =     pcRecoYuvBest->m_apiBufV + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
  
				iSrcStride = pcRecoYuvBest_8x8->m_iWidth;
				iDstStride =     pcRecoYuvBest->m_iWidth;
				
				y = pcRecoYuvBest_8x8->m_iHeight;
				for( y; y!=0; y-- )
				{
					memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
					pDst += iDstStride;
					pSrc += iSrcStride;
				}
				
				iSrcStride = pcRecoYuvBest_8x8->m_iCWidth;
				iDstStride =     pcRecoYuvBest->m_iCWidth;
				
				y = pcRecoYuvBest_8x8->m_iCHeight;
				for ( y; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				}	
			}
			
			//最佳8x8块已拷贝结束，可销毁CU和YUV空间
			destoryCurCU_cos(pcSubBestPartCU);
			destoryCurYuv_cos(pcPredYuvBest_8x8);
			destoryCurYuv_cos(pcRecoYuvBest_8x8);
			destoryCurYuv_cos(pcResiYuvBest_8x8) ;  //删除临时16x16 CU开辟的空间;并置指针为NULL，
			
			if(++uiPartUnitIdx == 4) //4个8x8块均接收到，对临时最佳16x16块编码
			{
				uiPartUnitIdx = 0; //重置0，用于标记下一个16x16块的开始
				
				//m_pcEntropyCoder->resetBits();  //这里的熵编码器的上一个状态是encodeRelated_8x8中第3号8x8进行encodeSplitFlag_cos编码结束之后的状态
				//m_pcEntropyCoder->encodeSplitFlag( rpcBestCU_16x16, 0, uiDepth, true );

				//rpcBestCU_16x16->getTotalBits() += m_pcEntropyCoder->getNumberOfWrittenBits(); // split bits
				//rpcBestCU_16x16->getTotalBins() += ((TEncBinCABAC *)((TEncSbac*)m_pcEntropyCoder->m_pcEntropyCoderIf)->getEncBinIf())->getBinsCoded();
				//rpcBestCU_16x16->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_16x16->getTotalBits(), rpcBestCU_16x16->getTotalDistortion() );
			
				//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_16x16, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU_16x16->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU_16x16->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_16x16->getTotalBits(), rpcBestCU_16x16->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU_16x16->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_16x16->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU_16x16->m_dTotalCost = dRdCost;
				
				//xCheckBestMode( rpcBestCU_16x16, rpcBestCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
			}

			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_16x16;	
			Out[0].ulpcOrigYuv = (unsigned long)pcOrigYuv;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
			
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的8x8并将其拷贝至16x16的相应位置
			Out tumbling(1);
		}	
	};
}


//16x16块的帧间预测
composite xCheckRDCostInter16x16_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
									  input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out2;
	
	Out2 = splitjoin(In)
	{
		UChar uhDepth = 2;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //16x16块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //16x16块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //16x16块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //16x16块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //16x16块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //16x16块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //16x16块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //16x16块的nRx2N模式
		}	
		join roundrobin(1);
	};
	Out = encodeRelated_16x16(Out2)
	{
		int iCount;
		int uiDepth;
		TComDataCU* rpcBestCU;
		TComYuv *pcOrigYuv;
		TComYuv *pcPredYuvBest;
		TComYuv *pcRecoYuvBest;
		TComYuv *pcResiYuvBest;
		init
		{
			iCount = 0;
			uiDepth = 2;
			rpcBestCU = 0;
			pcOrigYuv = 0;
			pcPredYuvBest = 0;
			pcRecoYuvBest = 0;
			pcResiYuvBest = 0;
		}
		work
		{
			if(++iCount > 4*8-8)
			{
				TComDataCU* rpcTempCU =   (TComDataCU*)(Out2[0].ulpcTempCU);
				TComYuv * pcPredYuvTemp = (TComYuv *)(Out2[0].ulpcPredYuv);
				TComYuv * pcRecoYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuv);
				TComYuv * pcResiYuvTemp = (TComYuv *)(Out2[0].ulpcResiYuv);
				
				//定义编码器
				TEncEntropy* m_pcEntropyCoder = &(m_pcEncTop->m_cEntropyCoder);
	
				TComRdCost* m_pcRdCost = &(m_pcEncTop->m_cRdCost);
				double dRdCost = 0.0;
				
				if(iCount == 4*8-8+1)  //25-32分别为8种模式
				{
					//赋初值
					rpcBestCU  = (TComDataCU*)(Out2[0].ulpcBestCU);  // In[0]  
					pcOrigYuv = (TComYuv *)(Out2[0].ulpcOrigYuv); 
					pcPredYuvBest = (TComYuv *)(Out2[0].ulpcPredYuvBest);  //Merge模式的最佳预测
					pcRecoYuvBest = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //Merge模式的最佳
					pcResiYuvBest = (TComYuv *)(Out2[0].ulpcResiYuv);  //Merge模式的最佳
					
					//删除原始Yuv
					destoryCurYuv_cos(pcOrigYuv);
	
				}
					
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;
					
					pcYuv = pcResiYuvBest;
					pcResiYuvBest = pcResiYuvTemp;
					pcResiYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
						
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU->m_dTotalCost = dRdCost;  
			
				if(iCount == 32)
				{
					copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

					xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth,pcRecoYuvBest);    //至此，一个16x16块的计算全部完成
				
					Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU;
					Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
					Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
					Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
					iCount = 0;
					
					//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
				
					//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
					//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
	
				}
			}
					
		}
		window
		{
			Out2 sliding(1,1);  // 2Nx2N模式和 NxN模式的输入
			Out tumbling(1);
		}
		
	};
}

//将某一16x16最终的CU状态及YUV拷贝至上一层32x32 CU的相应位置,也即32x32的分割模式
composite copyPartTo_32x32(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_32x32(In)
	{
		int iCount;
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的32x32块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_32x32;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			iCount = 0;
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 1;
			uhWidth  = 32;
			uhHeight = 32;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_32x32 = NULL;  
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
			if(++iCount == 32)
			{
				//pcCU为LCU的指针
				TComPic* pcPic = pcCU->m_pcPic;
				TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
				
				int y;
				Pel* pDst, *pDstU, *pDstV;
				Pel* pSrc, *pSrcU, *pSrcV;
				UInt iDstStride, iSrcStride,iWidth,iCWidth;
				
				
				UInt iCuAddr = pcCU->m_uiCUAddr;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				double dRdCost = 0.0; 
				
				//从 encodeRelated_16x16 的输出得到的最佳块的信息;待完成
				TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);
				TComYuv *pcPredYuvBest_16x16 = (TComYuv *)(In[0].ulpcPredYuvBest);
				TComYuv *pcRecoYuvBest_16x16 = (TComYuv *)(In[0].ulpcRecoYuvBest);
				TComYuv *pcResiYuvBest_16x16 = (TComYuv *)(In[0].ulpcResiYuvBest); //根据输入完成
				
				if(uiPartUnitIdx== 0)  //说明是在处理一个新的32x32块
				{	
					createCurCU_cos(pcCU,rpcBestCU_32x32,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
		
					createCurYuv_cos(pcOrigYuv,32,32);  //创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcPredYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcRecoYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcResiYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
					
					//pcOrigYuv 原始yuv数据拷贝
					//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
					{
						int  y;
						short* pDst  = pcOrigYuv->m_apiBufY; 
						short* pDstU = pcOrigYuv->m_apiBufU;
						short* pDstV = pcOrigYuv->m_apiBufV;
						//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
						Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
						Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
						Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
						
						//copyFromPicLuma
						UInt  iDstStride  =  pcOrigYuv->m_iWidth;
						UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
						UInt  iWidth = pcOrigYuv->m_iWidth;
						UInt  iCWidth = pcOrigYuv->m_iCWidth;
						for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
						{
							memcpy( pDst, pSrc, sizeof(short)*iWidth);
							pDst += iDstStride;
							pSrc += iSrcStride;
						}
						
						//copyFromPicChroma
						iDstStride = pcOrigYuv->m_iCWidth;
						iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
						for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
						{
							memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
							memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
							pSrcU += iSrcStride;
							pSrcV += iSrcStride;
							pDstU += iDstStride;
							pDstV += iDstStride;
						} 				
					}
					
					uiAbsZorderIdx += 64;  //每处理完一个32x32块，Zorder自增64;
					if(uiAbsZorderIdx == 256)
					{
						uiAbsZorderIdx = 0;
					}
				}
				
				//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
				//rpcBestCU_16x16->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
				copyPartFrom_cos(rpcBestCU_32x32,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
				
				//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
				{
					
					//计算第uiPartUnitIdx个16x16子块在32x32块中对应位置
					UInt uiDstPartIdx = 16*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
					
					pSrc  = pcRecoYuvBest_16x16->m_apiBufY;
					pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
					
					pSrcU = pcRecoYuvBest_16x16->m_apiBufU;
					pSrcV = pcRecoYuvBest_16x16->m_apiBufV;
					pDstU =     pcRecoYuvBest->m_apiBufU + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
					pDstV =     pcRecoYuvBest->m_apiBufV + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
	  
					iSrcStride = pcRecoYuvBest_16x16->m_iWidth;
					iDstStride =     pcRecoYuvBest->m_iWidth;
					
					y = pcRecoYuvBest_16x16->m_iHeight;
					for( y; y!=0; y-- )
					{
						memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					iSrcStride = pcRecoYuvBest_16x16->m_iCWidth;
					iDstStride =     pcRecoYuvBest->m_iCWidth;
					
					y = pcRecoYuvBest_16x16->m_iCHeight;
					for ( y; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					}	
				}
				
				destoryCurCU_cos(pcSubBestPartCU);
				destoryCurYuv_cos(pcPredYuvBest_16x16);
				destoryCurYuv_cos(pcRecoYuvBest_16x16);
				destoryCurYuv_cos(pcResiYuvBest_16x16);
				
				if(++uiPartUnitIdx == 4) //4个16x16块均接收到，对临时最佳32x32块编码
				{
					uiPartUnitIdx = 0; //重置0，用于标记下一个32x32块的开始
					
					//m_pcEntropyCoder->resetBits();  //这里的熵编码器的上一个状态是encodeRelated_8x8中第3号8x8进行encodeSplitFlag_cos编码结束之后的状态
					//m_pcEntropyCoder->encodeSplitFlag( rpcBestCU_32x32, 0, uiDepth, true );

					//rpcBestCU_32x32->getTotalBits() += m_pcEntropyCoder->getNumberOfWrittenBits(); // split bits
					//rpcBestCU_32x32->getTotalBins() += ((TEncBinCABAC *)((TEncSbac*)m_pcEntropyCoder->m_pcEntropyCoderIf)->getEncBinIf())->getBinsCoded();
					//rpcBestCU_32x32->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_32x32->getTotalBits(), rpcBestCU_32x32->getTotalDistortion() );
				
					//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
					
					resetBits_cos(m_pcEntropyCoder);
					encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_32x32, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
					rpcBestCU_32x32->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
					rpcBestCU_32x32->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
					//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_32x32->getTotalBits(), rpcBestCU_32x32->getTotalDistortion() );
					dRdCost = ((Double)rpcBestCU_32x32->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_32x32->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
					dRdCost = (Double)(UInt)floor(dRdCost);
					rpcBestCU_32x32->m_dTotalCost = dRdCost;
					
					//xCheckBestMode( rpcBestCU_32x32, rpcTempCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
				}	
				
				Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_32x32;	
				Out[0].ulpcOrigYuv =  (unsigned long)pcOrigYuv;
				Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
				Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
				Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
				
				iCount = 0;
			}
	        
			
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的16x16并将其拷贝至32的相应位置
			Out tumbling(1);
		}	
	};
}


//32x32块的帧间预测
composite xCheckRDCostInter32x32_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                                      input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out2;
		  
	Out2 = splitjoin(In)
	{
		UChar uhDepth = 1;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //32x32 块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //32x32 块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //32x32 块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //32x32 块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //32x32 块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //32x32 块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //32x32 块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //32x32 块的nRx2N模式
		}	
		join roundrobin(1);
	};
	Out = encodeRelated_32x32(Out2)
	{
		int iCount;
		int uiDepth;
		TComDataCU* rpcBestCU;
		TComYuv *pcOrigYuv;
		TComYuv *pcPredYuvBest;
		TComYuv *pcRecoYuvBest;
		TComYuv *pcResiYuvBest;
		init
		{
			iCount = 0;
			uiDepth = 1;
			rpcBestCU = 0;
			pcOrigYuv = 0;
			pcPredYuvBest = 0;
			pcRecoYuvBest = 0;
			pcResiYuvBest = 0;
		}
		work
		{
			if(++iCount > 128*8-8)
			{
				TComDataCU* rpcTempCU =   (TComDataCU*)(Out2[0].ulpcTempCU);
				TComYuv * pcPredYuvTemp = (TComYuv *)(Out2[0].ulpcPredYuv);
				TComYuv * pcRecoYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuv);
				TComYuv * pcResiYuvTemp = (TComYuv *)(Out2[0].ulpcResiYuv);
				
				//定义编码器
				TEncEntropy* m_pcEntropyCoder = &(m_pcEncTop->m_cEntropyCoder);
	
				TComRdCost* m_pcRdCost = &(m_pcEncTop->m_cRdCost);
				double dRdCost = 0.0;
				
				if(iCount == 128*8-8+1)  //25-32分别为8种模式
				{
					//赋初值
					rpcBestCU  = (TComDataCU*)(Out2[0].ulpcBestCU);  // In[0]  
					pcOrigYuv = (TComYuv *)(Out2[0].ulpcOrigYuv); 
					pcPredYuvBest = (TComYuv *)(Out2[0].ulpcPredYuvBest);  //Merge模式的最佳预测
					pcRecoYuvBest = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //Merge模式的最佳
					pcResiYuvBest = (TComYuv *)(Out2[0].ulpcResiYuv);  //Merge模式的最佳
					
					//删除原始Yuv
					destoryCurYuv_cos(pcOrigYuv);
	
				}
					
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;
					
					pcYuv = pcResiYuvBest;
					pcResiYuvBest = pcResiYuvTemp;
					pcResiYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
						
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU->m_dTotalCost = dRdCost;  
			
				if(iCount == 1024)
				{
					copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

					xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth,pcRecoYuvBest);    //至此，一个16x16块的计算全部完成
				
					Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU;
					Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
					Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
					Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
					iCount = 0;
					
					//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
				
					//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
					//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
	
				}
			}
					
		}
		window
		{
			Out2 sliding(1,1);  // 2Nx2N模式和 NxN模式的输入
			Out tumbling(1);
		}
		
	};
	
}

//将某一32x32最终的CU状态及YUV拷贝至上一层64x64 CU的相应位置,也即64x64的分割模式
composite copyPartTo_64x64(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_64x64(In)
	{
		int iCount;
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的32x32块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_64x64;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			iCount = 0;
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 0;
			uhWidth  = 64;
			uhHeight = 64;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_64x64 = NULL;  
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
			if(++iCount == 1024)
			{
				//pcCU为LCU的指针
			
				TComPic* pcPic = pcCU->m_pcPic;
				TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
				
				int y;
				Pel* pDst, *pDstU, *pDstV;
				Pel* pSrc, *pSrcU, *pSrcV;
				UInt iDstStride, iSrcStride,iWidth,iCWidth;
				
				UInt iCuAddr = pcCU->m_uiCUAddr;
				
				//定义编码器
				TEncEntropy m_cEntropyCoder;
				TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
				
				//定义TComRdCost类型变量
				TComRdCost m_cRdCost;
				TComRdCost* m_pcRdCost = &m_cRdCost;
				
				double dRdCost = 0.0; 
				
				//从 encodeRelated_32x32 的输出得到的最佳块的信息;待完成
				TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);
				TComYuv *pcPredYuvBest_32x32 = (TComYuv *)(In[0].ulpcPredYuvBest);
				TComYuv *pcRecoYuvBest_32x32 = (TComYuv *)(In[0].ulpcRecoYuvBest);
				TComYuv *pcResiYuvBest_32x32 = (TComYuv *)(In[0].ulpcResiYuvBest);  //根据输入完成;  //根据输入完成
				
				if(uiPartUnitIdx== 0)  //说明是在处理一个新块
				{	
					createCurCU_cos(pcCU,rpcBestCU_64x64,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
		
					createCurYuv_cos(pcOrigYuv,64,64);  //创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcPredYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcRecoYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
					
					createCurYuv_cos(pcResiYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
					
					//pcOrigYuv 原始yuv数据拷贝
					//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
					{
						int  y;
						short* pDst  = pcOrigYuv->m_apiBufY; 
						short* pDstU = pcOrigYuv->m_apiBufU;
						short* pDstV = pcOrigYuv->m_apiBufV;
						//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
						Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
						Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
						Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
						
						//copyFromPicLuma
						UInt  iDstStride  =  pcOrigYuv->m_iWidth;
						UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
						UInt  iWidth = pcOrigYuv->m_iWidth;
						UInt  iCWidth = pcOrigYuv->m_iCWidth;
						for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
						{
							memcpy( pDst, pSrc, sizeof(short)*iWidth);
							pDst += iDstStride;
							pSrc += iSrcStride;
						}
						
						//copyFromPicChroma
						iDstStride = pcOrigYuv->m_iCWidth;
						iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
						for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
						{
							memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
							memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
							pSrcU += iSrcStride;
							pSrcV += iSrcStride;
							pDstU += iDstStride;
							pDstV += iDstStride;
						} 				
					}
					
					uiAbsZorderIdx += 64;  //每处理完一个32x32块，Zorder自增64;
					if(uiAbsZorderIdx == 256)  
					{
						uiAbsZorderIdx = 0;
					}
				}
				
				//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
				//rpcBestCU_64x64->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
				copyPartFrom_cos(rpcBestCU_64x64,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
				
				//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
				{
					
					//计算第uiPartUnitIdx个16x16子块在32x32块中对应位置
					UInt uiDstPartIdx = 16*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
					
					pSrc  = pcRecoYuvBest_32x32->m_apiBufY;
					pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
					
					pSrcU = pcRecoYuvBest_32x32->m_apiBufU;
					pSrcV = pcRecoYuvBest_32x32->m_apiBufV;
					pDstU =     pcRecoYuvBest->m_apiBufU + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
					pDstV =     pcRecoYuvBest->m_apiBufV + (( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1);
	  
					iSrcStride = pcRecoYuvBest_32x32->m_iWidth;
					iDstStride =     pcRecoYuvBest->m_iWidth;
					
					y = pcRecoYuvBest_32x32->m_iHeight;
					for( y; y!=0; y-- )
					{
						memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					iSrcStride = pcRecoYuvBest_32x32->m_iCWidth;
					iDstStride =     pcRecoYuvBest->m_iCWidth;
					
					y = pcRecoYuvBest_32x32->m_iCHeight;
					for ( y; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					}	
				}
				destoryCurCU_cos(pcSubBestPartCU);
				destoryCurYuv_cos(pcPredYuvBest_32x32);
				destoryCurYuv_cos(pcRecoYuvBest_32x32);
				destoryCurYuv_cos(pcResiYuvBest_32x32) ;  //删除临时16x16 CU开辟的空间;并置指针为NULL，
				
				if(++uiPartUnitIdx == 4) //4个32x32块均接收到，对临时最佳64x64块编码
				{
					uiPartUnitIdx = 0; //重置0，用于标记下一个64x64块的开始
					
					//m_pcEntropyCoder->resetBits();  //这里的熵编码器的上一个状态是encodeRelated_8x8中第3号8x8进行encodeSplitFlag_cos编码结束之后的状态
					//m_pcEntropyCoder->encodeSplitFlag( rpcBestCU_64x64, 0, uiDepth, true );

					//rpcBestCU_64x64->getTotalBits() += m_pcEntropyCoder->getNumberOfWrittenBits(); // split bits
					//rpcBestCU_64x64->getTotalBins() += ((TEncBinCABAC *)((TEncSbac*)m_pcEntropyCoder->m_pcEntropyCoderIf)->getEncBinIf())->getBinsCoded();
					//rpcBestCU_64x64->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_64x64->getTotalBits(), rpcBestCU_64x64->getTotalDistortion() );
				
					//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
					
					resetBits_cos(m_pcEntropyCoder);
					encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_64x64, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
					rpcBestCU_64x64->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
					rpcBestCU_64x64->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
					//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_64x64->getTotalBits(), rpcBestCU_64x64->getTotalDistortion() );
					dRdCost = ((Double)rpcBestCU_64x64->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_64x64->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
					dRdCost = (Double)(UInt)floor(dRdCost);
					rpcBestCU_64x64->m_dTotalCost = dRdCost;
					//xCheckBestMode( rpcBestCU_64x64, rpcTempCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
				}

				Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_64x64;	
				Out[0].ulpcOrigYuv =  (unsigned long)pcOrigYuv;
				Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
				Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
				Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;			
				iCount = 0;
				
			}
	        
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的32x32并将其拷贝至64x64的相应位置
			Out tumbling(1);
		}	
	};
}


//64x64 块的帧间预测
composite xCheckRDCostInter64x64_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                   unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                      input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = splitjoin(In)
	{
		UChar uhDepth = 0;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //64x64 块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //64x64 块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //64x64 块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //64x64 块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //64x64 块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //64x64 块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //64x64 块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //64x64 块的nRx2N模式
		}	
		join roundrobin(1);
	};
}


composite Main()
{
	stream<unsigned long ulpcOrigYuv> Out1;
	stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out2,Out4,Out6;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out3,Out5,Out7;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out8;
	Out1 = initSubCU_8x8()
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			 //PartSize SIZE_2Nx2N = SIZE_2Nx2N;
			 //TComDataCU* rpcTempCU = pcCU;
			 //char c = (&(rpcTempCU->m_acCUMvField[0]))->m_piRefIdx[0];  //取地址不行！！
			 //char c = (rpcTempCU->m_acCUMvField[0]).m_piRefIdx[0];
			 
			 UChar       uiDepth       = 3;
			 UChar uhWidth  = 64 >> uiDepth;
             UChar uhHeight = 64 >> uiDepth;
			 
			 TComPic* pcPic = pcCU->m_pcPic;
			 TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			 Int iQP = pcCU->m_phQP[0];
			 UInt iCuAddr = pcCU->m_uiCUAddr;
			
 			 TComYuv *pcOrigYuv = NULL;  //原始YUV
			 createCurYuv_cos(pcOrigYuv,8,8);  //创建原始YUV空间并初始化，注意释放空间
			
			//原始yuv数据拷贝
			 {
				int  y;
				short* pDst  = pcOrigYuv->m_apiBufY; 
				short* pDstU = pcOrigYuv->m_apiBufU;
				short* pDstV = pcOrigYuv->m_apiBufV;
				//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
				Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
				Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_cuOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
				Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_cuOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
				
				//copyFromPicLuma
				UInt  iDstStride  =  pcOrigYuv->m_iWidth;
				UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
				UInt  iWidth = pcOrigYuv->m_iWidth;
				UInt  iCWidth = pcOrigYuv->m_iCWidth;
				for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
				{
					memcpy( pDst, pSrc, sizeof(short)*iWidth);
                    pDst += iDstStride;
                    pSrc += iSrcStride;
                }
				
				//copyFromPicChroma
				iDstStride = pcOrigYuv->m_iCWidth;
				iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
				for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				} 				
			 }
			 
			Out1[0].ulpcOrigYuv = (unsigned long)pcOrigYuv;
			 
			uiAbsZorderIdx += 4;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) 
			{
				uiAbsZorderIdx = 0;
			}
		
		} 
		window
		{
			Out1 tumbling(1);
		}
	};
	
	
	Out2 = xCheckRDCostInter8x8_cos(Out1)();
	
	Out3 = copyPartTo_16x16(Out2)();
	
	Out4 = xCheckRDCostInter16x16_cos(Out3)();
	
	Out5 = copyPartTo_32x32(Out4)();
	
	Out6 = xCheckRDCostInter32x32_cos(Out5)();
	
	Out7 = copyPartTo_64x64(Out6)();
	
	Out8 = xCheckRDCostInter64x64_cos(Out7)();
	
	encodeRelated_64x64(Out8)
	{
		int iCount;
		int uiDepth;
		TComDataCU* rpcBestCU;
		TComYuv *pcOrigYuv;
		TComYuv *pcPredYuvBest;
		TComYuv *pcRecoYuvBest;
		TComYuv *pcResiYuvBest;
		init
		{
			iCount = 0;
			uiDepth = 0;
			rpcBestCU = 0;
			pcOrigYuv = 0;
			pcPredYuvBest = 0;
			pcRecoYuvBest = 0;
			pcResiYuvBest = 0;
		}
		work
		{
			if(++iCount > 4096*8-8)
			{
				TComDataCU* rpcTempCU =   (TComDataCU*)(Out8[0].ulpcTempCU);
				TComYuv * pcPredYuvTemp = (TComYuv *)(Out8[0].ulpcPredYuv);
				TComYuv * pcRecoYuvTemp = (TComYuv *)(Out8[0].ulpcRecoYuv);
				TComYuv * pcResiYuvTemp = (TComYuv *)(Out8[0].ulpcResiYuv);
				
				//定义编码器
				TEncEntropy* m_pcEntropyCoder = &(m_pcEncTop->m_cEntropyCoder);
	
				TComRdCost* m_pcRdCost = &(m_pcEncTop->m_cRdCost);
				double dRdCost = 0.0;
				
				if(iCount == 4096*8-8+1)  //25-32分别为8种模式
				{
					//赋初值
					rpcBestCU  = (TComDataCU*)(Out8[0].ulpcBestCU);  // In[0]  
					pcOrigYuv = (TComYuv *)(Out8[0].ulpcOrigYuv); 
					pcPredYuvBest = (TComYuv *)(Out8[0].ulpcPredYuvBest);  //Merge模式的最佳预测
					pcRecoYuvBest = (TComYuv *)(Out8[0].ulpcRecoYuvBest);  //Merge模式的最佳
					pcResiYuvBest = (TComYuv *)(Out8[0].ulpcResiYuv);  //Merge模式的最佳
					
					//删除原始Yuv
					destoryCurYuv_cos(pcOrigYuv);
	
				}
					
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;
					
					pcYuv = pcResiYuvBest;
					pcResiYuvBest = pcResiYuvTemp;
					pcResiYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
						
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU->m_dTotalCost = dRdCost;  
			
				if(iCount == 4096*8)
				{
					copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

					xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth,pcRecoYuvBest);    //至此，一个16x16块的计算全部完成
				
					//Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU;
					//Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
					//Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
					//Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
					iCount = 0;
					
					//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
				
					//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
					//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
					
					//删除第0层的最佳CU，Yuv
					destoryCurCU_cos(rpcBestCU);
					destoryCurYuv_cos(pcPredYuvBest);
					destoryCurYuv_cos(pcRecoYuvBest);
					destoryCurYuv_cos(pcResiYuvBest);
	
				}
			}
					
		}
		window
		{
			Out8 sliding(1,1);  //输入为 join的8个分支
		}
	};

}
