//注：相对I、P帧 对m_cRdCost 进行了初始化 ， m_pcRdCost存在于TEncSlice和TEncCu对象中，均获取的是TEncTop中m_cRdCost对象的地址
//对m_cTrQuant初始化 , m_cTrQuant的init ， initEncSlice() 和 量化列表的设置 ，封装在 initTComTrQuant()函数中；
//设置熵编码器：m_pcEntropyCoder->setEntropyCoder(m_pcRDGoOnSbacCoder, pcSlice);
//m_pcEntropyCoder->setBitstream( &m_pcBitCounters[0] );  

#define UInt unsigned int
//#define bool bool   //costream不支持bool类型，用unsigned char型代替
#define bool int
#define Pel short
#define Int int
#define Double double
#define Float float
#define Char char
#define UChar unsigned char
#define NULL 0x0000000000000000
#define true 1
#define false 0

#define MAX_UINT                    0xFFFFFFFFU ///< max. value of unsigned 32-bit integer
#define MAX_INT                     2147483647  ///< max. value of signed 32-bit integer
#define MAX_INT64                   0x7FFFFFFFFFFFFFFFLL  ///< max. value of signed 64-bit integer
#define MAX_DOUBLE                  1.7e+308    ///< max. value of double-type value

//typedef       long Int64;  //8 bytes
//typedef       unsigned long  UInt64 //8 bytes

typedef       long long         Int64;   //在linux下测试大小为 8 bytes
typedef       unsigned long long  UInt64;//在linux下测试大小为 8 bytes

struct TComDataCU;  //前向声明结构体
typedef struct TComDataCU TComDataCU;

struct TComSlice
{
	Double      m_lambdas[3];
	Int         m_iDepth;
	Int  m_aiNumRefIdx[2];    //  for multiple reference of current slice
	bool m_bLMvdL1Zero;
	Int  m_list1IdxToList0Idx[16];
};
typedef struct TComSlice TComSlice; 

struct TComPicSym
{
	UInt          m_uiWidthInCU;
	UInt          m_uiHeightInCU;
  
	UInt          m_uiMaxCUWidth;
	UInt          m_uiMaxCUHeight;
	UInt          m_uiMinCUWidth;
	UInt          m_uiMinCUHeight;
  
	UChar         m_uhTotalDepth;       ///< max. depth
	UInt          m_uiNumPartitions;
	UInt          m_uiNumPartInWidth;
	UInt          m_uiNumPartInHeight;
	UInt          m_uiNumCUsInFrame;
	
	TComSlice**   m_apcTComSlice;
	TComDataCU**  m_apcTComDataCU; 	
};

typedef struct TComPicSym TComPicSym;

struct TComPicYuv
{
  Pel*  m_apiPicBufY;           ///< Buffer (including margin)
  Pel*  m_apiPicBufU;
  Pel*  m_apiPicBufV;
  
  Pel*  m_piPicOrgY;            ///< m_apiPicBufY + m_iMarginLuma*getStride() + m_iMarginLuma
  Pel*  m_piPicOrgU;
  Pel*  m_piPicOrgV;
  
  // ------------------------------------------------------------------------------------------------
  //  Parameter for general YUV buffer usage
  // ------------------------------------------------------------------------------------------------
  
  Int   m_iPicWidth;            ///< Width of picture
  Int   m_iPicHeight;           ///< Height of picture
  
  Int   m_iCuWidth;             ///< Width of Coding Unit (CU)
  Int   m_iCuHeight;            ///< Height of Coding Unit (CU)
  Int*  m_cuOffsetY;
  Int*  m_cuOffsetC;
  Int*  m_buOffsetY;
  Int*  m_buOffsetC;
  
  Int   m_iLumaMarginX;
  Int   m_iLumaMarginY;
  Int   m_iChromaMarginX;
  Int   m_iChromaMarginY;
  
  bool  m_bIsBorderExtended;
};

typedef struct TComPicYuv TComPicYuv;

struct TComPic
{
	
	UInt                  m_uiTLayer;               //  Temporal layer
	bool                  m_bUsedByCurr;            //  Used by current picture
	bool                  m_bIsLongTerm;            //  IS long term picture
	
	TComPicSym*           m_apcPicSym;  
	TComPicYuv*           m_apcPicYuv[2];           //  Texture,  0:org / 1:rec
  
    TComPicYuv*           m_pcPicYuvPred;           //  Prediction
    TComPicYuv*           m_pcPicYuvResi;           //  Residual
	
};
typedef struct TComPic TComPic;


struct TComMv
{
	short m_iHor;
	short m_iVer;
};
typedef struct TComMv TComMv;

struct TComMvField
{
	TComMv m_acMv;
	Int    m_iRefIdx;
};
typedef struct TComMvField TComMvField;

typedef struct _AMVPInfo
{
	TComMv m_acMvCand[3];  ///< array of motion vector predictor candidates
    Int    iN;                                ///< number of motion vector predictor candidates
}AMVPInfo;

struct TComCUMvField
{
  TComMv*   m_pcMv;
  TComMv*   m_pcMvd;
  Char*     m_piRefIdx;
  UInt      m_uiNumPartition;
  AMVPInfo  m_cAMVPInfo;  
};
typedef struct TComCUMvField TComCUMvField;


struct TComDataCU
{
	UInt m_uiCUAddr;
	UInt m_uiAbsIdxInLCU;
	UInt          m_uiCUPelX;           ///< CU position in a pixel (X)
    UInt          m_uiCUPelY;  
	TComPic*      m_pcPic;              ///< picture class pointer
	TComSlice*    m_pcSlice;            ///< slice header pointer
	
	UChar* m_puhDepth;  
	bool* m_skipFlag;
	Char* m_pePartSize;
	Char* m_pePredMode;         ///< array of prediction modes
	Char* m_CUTransquantBypass;
	//bool* m_CUTransquantBypass;   ///< array of cu_transquant_bypass flags
	Char* m_phQP;               ///< array of QP values
	
	UChar* m_puhTrIdx;
	UChar* m_puhCbf[3];  
	UChar* m_puhTransformSkip[3];
    TComCUMvField m_acCUMvField[2];     ///< array of motion vectors
	UChar* m_puhLumaIntraDir; 
	
	Double m_dTotalCost;         ///< sum of partition RD costs
	UInt m_uiTotalDistortion; 
	UInt m_uiTotalBits;        ///< sum of partition bits
	UInt m_uiTotalBins;       ///< sum of partition bins 

	UChar*        m_puhChromaIntraDir;  ///< array of intra directions (chroma)
	UChar*        m_puhInterDir;	
	Char*         m_apiMVPIdx[2];       ///< array of motion vector predictor candidates
	Char*         m_apiMVPNum[2];  
};

struct TComYuv
{
  Pel*    m_apiBufY;
  Pel*    m_apiBufU;
  Pel*    m_apiBufV;
  
  // ------------------------------------------------------------------------------------------------------------------
  //  Parameter for general YUV buffer usage
  // ------------------------------------------------------------------------------------------------------------------
  
  UInt     m_iWidth;
  UInt     m_iHeight;
  UInt     m_iCWidth;
  UInt     m_iCHeight;
};
typedef struct TComYuv TComYuv;


struct TComTrQuant
{
  UInt     m_uiMaxTrSize;
  bool     m_bEnc;
  bool     m_useRDOQ;
  bool     m_useRDOQTS;
  bool     m_bUseAdaptQpSelect;
  bool     m_useTransformSkipFast;
  
};
typedef struct TComTrQuant TComTrQuant;

struct TEncSbac
{
	
};
typedef struct TEncSbac TEncSbac;

struct DistParam
{

  //Pel*  pOrg;   //!< 原始图像首地址 
  //Pel*  pCur;    //!< 参考图像首地址 
  //Int   iStrideOrg;   //!< 原始图像跨度  
  //Int   iStrideCur;  //!< 参考图像跨度 
  //Int   iRows;     //!< PU的宽度
  //Int   iCols;   //!< PU的高度
  //Int   iStep;
  //FpDistFunc DistFunc;  //!< 计算失真的函数指针  
  //Int   bitDepth;  //!< 位深
  bool    bApplyWeight;     // whether weithed prediction is used or not
};
typedef struct DistParam DistParam;


struct TEncSearch
{
	UChar*          m_puhQTTempTrIdx;
	UChar*          m_puhQTTempCbf[3];
	UChar*          m_puhQTTempTransformSkipFlag[3];
	
	Int* m_iYuvExtStride;
	Int m_iYuvExtStride;
	Int m_iYuvExtHeight;
	
	TComYuv   m_acYuvPred[2];
	TComYuv   m_cYuvPredTemp;
	
	TEncSbac*** m_pppcRDSbacCoder;
	TEncSbac* m_pcRDGoOnSbacCoder;
	DistParam       m_cDistParam;
	
	UInt  m_auiMVPIdxCost[3][3]; //th array bounds
	
};

typedef struct TEncSearch TEncSearch;

struct TComRdCost 
{
	Double  m_cbDistortionWeight;
    Double  m_crDistortionWeight; 
	Double  m_dLambda;
	double m_sqrtLamda;
	UInt  m_uiLambdaMotionSAD;
	UInt  m_uiLambdaMotionSSE;
	Double  m_dFrameLambda;
	TComMv m_mvPredictor;
	UInt   m_uiCost;
	Int    m_iCostScale;
	
};
typedef struct TComRdCost TComRdCost;

struct TEncEntropyIf
{
	
};
typedef struct TEncEntropyIf TEncEntropyIf;

struct TEncEntropy
{
	UInt    m_uiBakAbsPartIdx;
	UInt    m_uiBakChromaOffset;
	UInt    m_bakAbsPartIdxCU;
	TEncEntropyIf*      m_pcEntropyCoderIf;
};
typedef struct TEncEntropy TEncEntropy;



struct TEncTop
{
	//TEncSampleAdaptiveOffset m_cEncSAO;                     ///< sample adaptive offset class
	TEncSbac***             m_pppcRDSbacCoder;              ///< temporal storage for RD computation
    TEncSbac                m_cRDGoOnSbacCoder;             ///< going on SBAC model for RD stage
};

typedef struct TEncTop TEncTop;

struct TEncCu
{
	
};
typedef struct TEncCu TEncCu;

enum RefPicList
{
	REF_PIC_LIST_0 = 0,   ///< reference list 0
	REF_PIC_LIST_1 = 1,   ///< reference list 1
	REF_PIC_LIST_X = 100  ///< special mark
};
typedef enum RefPicList RefPicList;

enum PartSize
{
  SIZE_2Nx2N = 0,           ///< symmetric motion partition,  2Nx2N
  SIZE_2NxN,            ///< symmetric motion partition,  2Nx N
  SIZE_Nx2N,            ///< symmetric motion partition,   Nx2N
  SIZE_NxN,             ///< symmetric motion partition,   Nx N
  SIZE_2NxnU,           ///< asymmetric motion partition, 2Nx( N/2) + 2Nx(3N/2)
  SIZE_2NxnD,           ///< asymmetric motion partition, 2Nx(3N/2) + 2Nx( N/2)
  SIZE_nLx2N,           ///< asymmetric motion partition, ( N/2)x2N + (3N/2)x2N
  SIZE_nRx2N,           ///< asymmetric motion partition, (3N/2)x2N + ( N/2)x2N
  SIZE_NONE = 15
};
typedef enum PartSize PartSize;

enum PredMode
{
  MODE_INTER = 0,           ///< inter-prediction mode
  MODE_INTRA = 1,           ///< intra-prediction mode
  MODE_NONE = 15
};
typedef enum PredMode PredMode;

int g_auiZscanToRaster[256] = {0,1,16,17,2,3,18,19,32,33,48,49,34,35,50,51,
                               4,5,20,21,6,7,22,23,36,37,52,53,38,39,54,55,
							   64,65,80,81,66,67,82,83,96,97,112,113,98,99,114,115,
							   68,69,84,85,70,71,86,87,100,101,116,117,102,103,118,119,
							   8,9,24,25,10,11,26,27,40,41,56,57,42,43,58,59,
							   12,13,28,29,14,15,30,31,44,45,60,61,46,47,62,63,
							   72,73,88,89,74,75,90,91,104,105,120,121,106,107,122,123,
							   76,77,92,93,78,79,94,95,108,109,124,125,110,111,126,127,
							   128,129,144,145,130,131,146,147,160,161,176,177,162,163,178,179,
							   132,133,148,149,134,135,150,151,164,165,180,181,166,167,182,183,
							   192,193,208,209,194,195,210,211,224,225,240,241,226,227,242,243,
							   196,197,212,213,198,199,214,215,228,229,244,245,230,231,246,247,
							   136,137,152,153,138,139,154,155,168,169,184,185,170,171,186,187,
							   140,141,156,157,142,143,158,159,172,173,188,189,174,175,190,191,
							   200,201,216,217,202,203,218,219,232,233,248,249,234,235,250,251,
							   204,205,220,221,206,207,222,223,236,237,252,253,238,239,254,255};
							   
int g_auiZscanToRaster[256] = {0,1,16,17,2,3,18,19,32,33,48,49,34,35,50,51,
                               4,5,20,21,6,7,22,23,36,37,52,53,38,39,54,55,
							   64,65,80,81,66,67,82,83,96,97,112,113,98,99,114,115,
							   68,69,84,85,70,71,86,87,100,101,116,117,102,103,118,119,
							   8,9,24,25,10,11,26,27,40,41,56,57,42,43,58,59,
							   12,13,28,29,14,15,30,31,44,45,60,61,46,47,62,63,
							   72,73,88,89,74,75,90,91,104,105,120,121,106,107,122,123,
							   76,77,92,93,78,79,94,95,108,109,124,125,110,111,126,127,
							   128,129,144,145,130,131,146,147,160,161,176,177,162,163,178,179,
							   132,133,148,149,134,135,150,151,164,165,180,181,166,167,182,183,
							   192,193,208,209,194,195,210,211,224,225,240,241,226,227,242,243,
							   196,197,212,213,198,199,214,215,228,229,244,245,230,231,246,247,
							   136,137,152,153,138,139,154,155,168,169,184,185,170,171,186,187,
							   140,141,156,157,142,143,158,159,172,173,188,189,174,175,190,191,
							   200,201,216,217,202,203,218,219,232,233,248,249,234,235,250,251,
							   204,205,220,221,206,207,222,223,236,237,252,253,238,239,254,255};

							   
int g_auiRasterToPelX[256] = {0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
                              0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,
							  0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60};
							   
							   
int g_auiRasterToPelY[256] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                              4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
							  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
							  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
							  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
							  20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
							  24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
							  28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
							  32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
							  36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,
							  40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
							  44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,
							  48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
							  52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,
							  56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,56,
							  60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60};
							  
extern TEncTop* m_pcEncTop;
extern TEncCu* m_pcCuEncoder;
extern TComPic* pcPic;	//将pcPic作为外部变量，只能够实现单帧的区块滤波，若要实现多帧，将pcPic作为输入数据，放入In中，可定位到正确图像
//extern TComPicSym* 	pcPicSym = pcPic->m_apcPicSym;
extern TComPicSym* 	pcPicSym;
extern TComDataCU* pcCU;

extern TEncSbac*** m_pppcRDSbacCoder;
extern TEncSbac* m_pcRDGoOnSbacCoder;

extern TComRdCost* g_m_pcRdCost;  //作为外部变量，获取的是m_pcEncTop指针下的m_cRdCost对象的地址值；
extern TComTrQuant* g_m_pcTrQuant;

int m_maxCUHeight = 64;
int m_maxCUWidth = 64;
int m_numCTUsPic = 9;

//m_cRdCost对象dLambda值作为外部变量获取



//非8x8块
composite xCheckRDCostMerge(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                          unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostMerge(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{	
			//本地创建临时和最佳Yuv
			TComDataCU* rpcTempCU = NULL;
			TComDataCU* rpcBestCU  = NULL;
			
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL,*pcRecoYuv = NULL, *pcResiYuv = NULL ;  //没有加后缀的都表示临时；最佳的加Best后缀加以区别
			TComYuv *pcPredYuvBest = NULL,*pcRecoYuvBest = NULL, *pcResiYuvBest = NULL;
			
			TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
			UChar uhInterDirNeighbours[5];
			Int mergeCandBuffer[5];
			Int numValidMergeCand = 0;
			
			UInt ui = 0;
			//UChar uhDepth = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(2*uhDepth);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			UInt  uiPartAddr = 0;
			
			bool bestIsSkip = false;
			
			UInt iteration = 2;
			UInt uiNoResidual = 0;
			UInt uiMergeCand  = 0;
			
			bool bTransquantBypassFlag = false;
			
			//Int orgQP = rpcTempCU->m_phQP[0];
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;  //调用构造函数，其中调用 initScalingList()对量化/反量化系数开辟并初始化；
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟最佳和临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   createCurYuv_cos(pcPredYuvBest,uiWidth,uiHeight);
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   createCurYuv_cos(pcRecoYuvBest,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);   createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = true;
			m_pcTrQuant->m_useRDOQTS = true;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			initTComTrQuant(m_pcTrQuant,g_m_pcTrQuant);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			
			for( ui = 0; ui < 5; ++ui )
			{
				uhInterDirNeighbours[ui] = 0;
				mergeCandBuffer[ui] = 0;
			}
			
			memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb );
			
			getInterMergeCandidates_cos(rpcTempCU,0,0,cMvFieldNeighbours,uhInterDirNeighbours,numValidMergeCand,-1);
			
			for( uiNoResidual = 0; uiNoResidual < iteration; ++uiNoResidual )
			{
				for( uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )    //!< 遍历所有merging candidates
				{
					if(!(uiNoResidual==1 && mergeCandBuffer[uiMergeCand]==1))    //!< uiNoResidual等于0或者mergeCandBuffer[uiMergeCand]等于0时
					{
						if( !(bestIsSkip && uiNoResidual == 0) )     //!< bestIsSkip等于false或者uiNoResidual等于1时条件成立
						{
							bool isZero_QtRootCbfTemp = 0, getCbfY = 0, getCbfU = 0, getCbfV = 0;
							
							// set MC parameters
							memset( rpcTempCU->m_pePredMode,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							memset( rpcTempCU->m_CUTransquantBypass,bTransquantBypassFlag,uiCurrPartNumb );
							memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							setMergeFlagSubParts_cos(rpcTempCU,true,0,0,uhDepth);// interprets depth relative to LCU level
							setMergeIndexSubParts_cos(rpcTempCU,uiMergeCand, 0, 0, uhDepth ); // interprets depth relative to LCU level
							setInterDirSubParts_cos(rpcTempCU,uhInterDirNeighbours[uiMergeCand], 0, 0, uhDepth ); // interprets depth relative to LCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_0,cMvFieldNeighbours[0 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_1,cMvFieldNeighbours[1 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
						  
							// do MC
							//m_pcPredSearch->motionCompensation (rpcTempCU, pcPredYuv);   //!< 运动补偿  
							{
								//Int uiWidth  = 64>>uhDepth;
								//Int uiHeight = 64>>uhDepth;
								//UInt uiPartAddr = 0;
								Int  iPartIdx = 0;
								
								for(iPartIdx = 0; iPartIdx < 1; iPartIdx++)
								{
									if(xCheckIdenticalMotion_cos(m_pcPredSearch,rpcTempCU, uiPartAddr )) 
									{
										xPredInterUni_cos(m_pcPredSearch,rpcTempCU, uiPartAddr, uiWidth, uiHeight, REF_PIC_LIST_0, pcPredYuv,false );
									}//B帧
								    else
									{
										//xPredInterBi(rpcTempCU, uiPartAddr, uiWidth, uiHeight, pcPredYuv);  //执行代码如下
										Int  iRefList = 0;
								
										TComYuv* pcMbYuv;
										Int iRefIdx[2] = {-1,-1};
										
										for (iRefList = 0; iRefList < 2; iRefList++ )
										{
											RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
											//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
											//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
											iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
											if ( iRefIdx[iRefList] < 0 )
											{
												continue;
											}

											//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

											pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
											//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
											if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, true );
											}
											else
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, false );
											}
										}
									
										//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, uiWidth, uiHeight, pcPredYuv );
										{
											TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
											TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
											if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
											{
												//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
												addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
											}
											else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
											{
												//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );

												copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
											else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
											{
												//pcYuvSrc1->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );

												copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
											
											
										}
									}
								} 
							}
						  
							// estimate residual and encode everything
							//m_pcPredSearch->encodeResAndCalcRdInterCU(rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));          //!< 对残差进行编码并计算RDCost</p><p>  
							encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));
						  
							getCbfY = (rpcTempCU->m_puhCbf[0][0] & 0x1);
							getCbfU = (rpcTempCU->m_puhCbf[1][0] & 0x1); 
							getCbfV = (rpcTempCU->m_puhCbf[2][0] & 0x1);
							
							//isZero_QtRootCbfTemp = isZeroQtRootCbf_cos(rpcTempCU);  //判断 rpcTempCU->getQtRootCbf(0) == 0 的逻辑真假
							isZero_QtRootCbfTemp = (( getCbfY || getCbfU || getCbfV ) == 0);
							
							if ( uiNoResidual == 0 && isZero_QtRootCbfTemp )          //!< CBF为0，说明变换系数全为0  
							{
								// If no residual when allowing for one, then set mark to not try case where residual is forced to 0
								mergeCandBuffer[uiMergeCand] = 1;
							}
						  
							//rpcTempCU->setSkipFlagSubParts( isZero_QtRootCbfTemp, 0, uhDepth );
							memset(rpcTempCU->m_skipFlag,isZero_QtRootCbfTemp,uiCurrPartNumb);
							
							//xCheckDQP( rpcTempCU );
							//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth);           //!< 更新最佳模式  
							if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
							{
								TComYuv* pcYuv;
								// Change Information data
								TComDataCU* pcCU = rpcBestCU;
								rpcBestCU = rpcTempCU;
								rpcTempCU = pcCU;

								// Change Prediction data
								pcYuv = pcPredYuvBest;
								pcPredYuvBest = pcPredYuv;
								pcPredYuv = pcYuv;

								// Change Reconstruction data
								pcYuv = pcRecoYuvBest;
								pcRecoYuvBest = pcRecoYuv;
								pcRecoYuv = pcYuv;

								pcYuv = NULL;
								pcCU  = NULL;

								// store temp best CI for next CU coding
								//m_pppcRDSbacCoder[uhDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);	
							}
							
							//rpcTempCU->initEstData( uhDepth, orgQP, bTransquantBypassFlag );     //!< 重新初始化预测参数，为下一次预测做准备
							initEstData_cos(rpcTempCU,uhDepth, rpcTempCU->m_phQP[0], bTransquantBypassFlag);
							if( !bestIsSkip )
							{
								//bestIsSkip = isZeroQtRootCbf_cos(rpcBestCU); //rpcBestCU->getQtRootCbf(0) == 0;
								getCbfY = (rpcBestCU->m_puhCbf[0][0] & 0x1);
								getCbfU = (rpcBestCU->m_puhCbf[1][0] & 0x1); 
								getCbfV = (rpcBestCU->m_puhCbf[2][0] & 0x1);
							
								isZero_QtRootCbfTemp = ( getCbfY || getCbfU || getCbfV ) == 0;
								
								bestIsSkip = isZero_QtRootCbfTemp; //rpcBestCU->getQtRootCbf(0) == 0;
							}
						}
					}
				}	
			}
			
			//到此Merge模式的最佳CU状态已保存至rpcBestCU，最佳YUV已保存至pcPredYuvBest，临时CU和Yuv空间可以删除了
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuv);
			destoryCurYuv_cos(pcRecoYuv); //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurYuv_cos(pcResiYuv);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcBestCU;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuvBest;
			
			///////////////////////////////////
			//m_pppcRDSbacCoder[uhNextDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]);
			//////////////////////////////////
			  
				//由于我们是采用split的方式进行8x8块的两种模式，合并之后进行两次编码比较(在encodeRelated_8x8中)，在这里各自修复熵编码器的上下文等到join之后的encodeRelated_8x8中，其实只有一次即encodeRelated_8x8中for循环的第一次得到了修复
				//因此，这里修复没有作用
				//----- restore context models -----
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};	
}


composite xCheckRDCostInter(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 0, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				//TComMv        cMvSrchRngLT;
				//TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 1;
				Int           iNumPredDir = 2;
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3] = {3, 3, 5};
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2Nx2N;
				PartSize      SIZE_2Nx2N = SIZE_2Nx2N;
				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
    
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= (( m_pcRdCost->m_uiCost ) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU,(RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
						
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2Nx2N,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
					
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
					  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}	
				
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
    
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_Nx2N(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                 input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_Nx2N(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，0
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
		
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 2, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				//TComMv        cMvSrchRngLT;
				//TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，Nx2N模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth>>1;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_Nx2N;  //
				PartSize      SIZE_Nx2N = SIZE_Nx2N;  //

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 2 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 5; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 2);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list//
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= (( m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp]) >>16;
							//correct the bit-rate part of the current ref//
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost//
							uiCostTemp +=  ((m_pcRdCost->m_uiCost) * uiBitsTemp)>> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_Nx2N, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_Nx2N,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx,  rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx,  rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx,  rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx,  rpcTempCU->m_puhDepth[uiPartAddr]);
					
				
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_2NxN(output stream< unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                 input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_2NxN(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uiDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 1, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxN模式
				Int           iNumPredDir = 2;  //预测方向的数目，
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;   //2NxN模式的子块宽
				Int			  iRoiHeight = 64>>uhDepth>>1;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2NxN;  //
				PartSize      SIZE_2NxN = SIZE_2NxN;

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 7; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 1);
    
					//  Uni-directional prediction
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list//
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref//
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost//
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU,  (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_2NxN, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU,  (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_2NxN, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2NxN,uiPartAddr,iPartIdx);
				
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_2NxnU(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_2NxnU(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		init
		{
			uiAbsZorderIdx = 0;
			//uhDepth = 2;
		}
		work
		{
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			TComDataCU* rpcTempCU;  //临时开辟
			TComYuv *pcPredYuv, *pcRecoYuv, *pcResiYuv,*pcResiYuvBest;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
			
			
			//UChar uhDepth        = 2;  //当前CU的深度，0
			UInt  uiWidth        = 64>>uhDepth;
			UInt  uiHeight       = 64>>uhDepth;
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
			
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
		
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 4, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
			
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxnU模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
				Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2NxnU;  //
				PartSize      SIZE_2NxnU = SIZE_2NxnU;

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 7; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					//iRoiWidth     = getWidth(0);  //宽度不变
                    iRoiHeight    = ( iPartIdx == 0 ) ? (uiHeight>>2): (uiHeight >> 2)+(uiHeight >> 1);
                    uiPartAddr    = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb>>3);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ((m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_2NxnU, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_2NxnU, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2NxnU,uiPartAddr,iPartIdx);
			
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
				
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxnU, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_2NxnD(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_2NxnD(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		
		init
		{
			uiAbsZorderIdx = 0;
			//uhDepth = 2;
		}
		work
		{
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			TComDataCU* rpcTempCU;  //临时开辟
			TComYuv *pcPredYuv, *pcRecoYuv, *pcResiYuv,*pcResiYuvBest;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
			
			
			//UChar uhDepth        = 2;  //当前CU的深度，0
			UInt  uiWidth        = 64>>uhDepth;
			UInt  uiHeight       = 64>>uhDepth;
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
			
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 5, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
			
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxnU模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
				Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2NxnD;  //
				PartSize      SIZE_2NxnD = SIZE_2NxnD; 

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 7; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					//iRoiWidth     = getWidth(0);  //宽度不变
                    iRoiHeight    = ( iPartIdx == 0 ) ? (uiHeight>>2): (uiHeight >> 2)+(uiHeight >> 1);
                    uiPartAddr    = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb>>3);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_2NxnD, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_2NxnD, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2NxnD,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}
					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxnD, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_nLx2N(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_nLx2N(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		
		init
		{
			uiAbsZorderIdx = 0;
			//uhDepth = 2;
		}
		work
		{
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			TComDataCU* rpcTempCU;  //临时开辟
			TComYuv *pcPredYuv, *pcRecoYuv, *pcResiYuv,*pcResiYuvBest;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
			
			
			//UChar uhDepth        = 2;  //当前CU的深度，2
			UInt  uiWidth        = 64>>uhDepth;
			UInt  uiHeight       = 64>>uhDepth;
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
			
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 6, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
			
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxnU模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = uiWidth;   //2NxN模式的子块宽
				Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_nLx2N;  //
				PartSize      SIZE_nLx2N = SIZE_nLx2N;  //

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 2 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 5; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					//iRoiWidth     = getWidth(0);  //高度不变
					iRoiWidth    = ( iPartIdx == 0 ) ?  ( uiWidth >> 2 ) : ( uiWidth >> 1 ) +(uiWidth >> 2);
					uiPartAddr    = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb >> 4);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_nLx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_nLx2N, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_nLx2N,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_nLx2N, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_nRx2N(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                   input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	param UChar uhDepth;
	
	Out = xCheckRDCostInter_nRx2N(In)
	{
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		//UChar uhDepth;
		
		init
		{
			uiAbsZorderIdx = 0;
			//uhDepth = 2;
		}
		work
		{
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			TComDataCU* rpcTempCU;  //临时开辟
			TComYuv *pcPredYuv, *pcRecoYuv, *pcResiYuv,*pcResiYuvBest;  // 残余最佳在encodeResAndCalcRdInterCU 函数中用到
			
			
			//UChar uhDepth        = 2;  //当前CU的深度，0
			UInt  uiWidth        = 64>>uhDepth;
			UInt  uiHeight       = 64>>uhDepth;
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
				
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  //创建原始YUV空间并初始化，注意释放空间
			
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight);
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个16x16块，Zorder自增16;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 7, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
			
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxnU模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth = uiWidth;   //2NxN模式的子块宽
				Int			  iRoiHeight = uiHeight;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_nRx2N;  //
				PartSize      SIZE_nRx2N = SIZE_nRx2N;

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 2 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 5; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					//iRoiHeight   =  getHeight(0);  //高度不变
					
					iRoiWidth     = ( iPartIdx == 0 ) ? (uiWidth >> 2) + (uiWidth >> 1) : ( uiWidth >> 2 );
					uiPartAddr = ( iPartIdx == 0 ) ? 0 : (uiCurrPartNumb >> 2) + (uiCurrPartNumb >> 4);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += (m_pcRdCost->m_uiCost * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (pcCU->getSlice()->isInterB()) && (pcCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_nRx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_nRx2N, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
    
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_nRx2N,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						 // TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					      TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						  
  						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}
					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,  uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_nRx2N, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
			
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcBestCU = In[0].ulpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostMerge_8x8(output stream<unsigned long ulpcTempCU,unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostMerge_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{	
			//本地创建临时和最佳Yuv
			TComDataCU* rpcTempCU = NULL;
			TComDataCU* rpcBestCU  = NULL;
			
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL,*pcRecoYuv = NULL, *pcResiYuv = NULL ;  //没有加后缀的都表示临时；最佳的加Best后缀加以区别
			TComYuv *pcPredYuvBest = NULL,*pcRecoYuvBest = NULL, *pcResiYuvBest = NULL;
			
			TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
			UChar uhInterDirNeighbours[5];
			Int mergeCandBuffer[5];
			Int numValidMergeCand = 0;
			
			UInt ui = 0;
			//UChar uhDepth = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(2*uhDepth);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			UInt  uiPartAddr = 0;
			
			bool bestIsSkip = false;
			
			UInt iteration = 2;
			UInt uiNoResidual = 0;
			UInt uiMergeCand  = 0;
			
			bool bTransquantBypassFlag = false;
			
			//Int orgQP = rpcTempCU->m_phQP[0];
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟最佳和临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   createCurYuv_cos(pcPredYuvBest,uiWidth,uiHeight);
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   createCurYuv_cos(pcRecoYuvBest,uiWidth,uiHeight);//创建原始YUV空间并初始化，注意释放空间
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);   createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			
			for( ui = 0; ui < 5; ++ui )
			{
				uhInterDirNeighbours[ui] = 0;
				mergeCandBuffer[ui] = 0;
			}
			
			memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb );
			
			getInterMergeCandidates_cos(rpcTempCU,0,0,cMvFieldNeighbours,uhInterDirNeighbours,numValidMergeCand,-1);
			
			for( uiNoResidual = 0; uiNoResidual < iteration; ++uiNoResidual )
			{
				for( uiMergeCand = 0; uiMergeCand < numValidMergeCand; ++uiMergeCand )    //!< 遍历所有merging candidates
				{
					if(!(uiNoResidual==1 && mergeCandBuffer[uiMergeCand]==1))    //!< uiNoResidual等于0或者mergeCandBuffer[uiMergeCand]等于0时
					{
						if( !(bestIsSkip && uiNoResidual == 0) )     //!< bestIsSkip等于false或者uiNoResidual等于1时条件成立
						{
							bool isZero_QtRootCbfTemp = 0 , getCbfY = 0, getCbfU = 0, getCbfV = 0;
							
							// set MC parameters
							memset( rpcTempCU->m_pePredMode,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							memset( rpcTempCU->m_CUTransquantBypass,bTransquantBypassFlag,uiCurrPartNumb );
							memset( rpcTempCU->m_pePartSize,0,uiCurrPartNumb ); // interprets depth relative to LCU level
							setMergeFlagSubParts_cos(rpcTempCU,true,0,0,uhDepth);// interprets depth relative to LCU level
							setMergeIndexSubParts_cos(rpcTempCU,uiMergeCand, 0, 0, uhDepth ); // interprets depth relative to LCU level
							setInterDirSubParts_cos(rpcTempCU,uhInterDirNeighbours[uiMergeCand], 0, 0, uhDepth ); // interprets depth relative to LCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_0,cMvFieldNeighbours[0 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
							setAllMvField_cos( rpcTempCU,REF_PIC_LIST_1,cMvFieldNeighbours[1 + 2*uiMergeCand], 0, 0, 0 ); // interprets depth relative to rpcTempCU level
						  
							// do MC
							//m_pcPredSearch->motionCompensation (rpcTempCU, pcPredYuv);   //!< 运动补偿  
							{
								//Int uiWidth  = 64>>uhDepth;
								//Int uiHeight = 64>>uhDepth;
								//UInt uiPartAddr = 0;
								Int  iPartIdx = 0;
								
								for(iPartIdx = 0; iPartIdx < 1; iPartIdx++)  //对于2N*2N模式，划分为1
								{
									if(xCheckIdenticalMotion_cos(m_pcPredSearch,rpcTempCU, uiPartAddr )) 
									{
										xPredInterUni_cos(m_pcPredSearch,rpcTempCU, uiPartAddr, uiWidth, uiHeight, REF_PIC_LIST_0, pcPredYuv,false );
									}   //B帧
								    
									else
									{
										//xPredInterBi(rpcTempCU, uiPartAddr, uiWidth, uiHeight, pcPredYuv);  //执行代码如下
										Int  iRefList = 0;
								
										TComYuv* pcMbYuv;
										Int iRefIdx[2] = {-1,-1};
										for (iRefList = 0; iRefList < 2; iRefList++ )
										{
											RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
											//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
											//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
											iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
											if ( iRefIdx[iRefList] < 0 )
											{
												continue;
											}

											//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

											pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
											//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
											if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, true );
											}
											else
											{
												xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, eRefPicList, pcMbYuv, false );
											}
										}
									
										//xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, uiWidth, uiHeight, pcPredYuv );
										{
											TComYuv* pcYuvSrc0 = &(m_pcPredSearch->m_acYuvPred[0]);
											TComYuv* pcYuvSrc1 = &(m_pcPredSearch->m_acYuvPred[1]);
											if(iRefIdx[0] >= 0 && iRefIdx[1] >= 0)
											{
												//pcPredYuv->addAvg( pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
												addAvg_cos(pcPredYuv,pcYuvSrc0, pcYuvSrc1, uiPartAddr, uiWidth, uiHeight);
											}
											else if(iRefIdx[0] >= 0 && iRefIdx[1] < 0)
											{
												//pcYuvSrc0->copyPartToPartYuv( pcPredYuv, uiPartAddr, uiWidth, uiHeight );
												
												
												copyPartToPartLuma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc0,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
											else if(iRefIdx[0] < 0 && iRefIdx[1] >= 0)
											{
												
												
												copyPartToPartLuma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth, uiHeight);
												copyPartToPartChroma_cos(pcYuvSrc1,pcPredYuv, uiPartAddr, uiWidth>>1, uiHeight>>1);
											}
											
											
										}
									}
								    
								} 
							}
						  
							// estimate residual and encode everything
							//m_pcPredSearch->encodeResAndCalcRdInterCU(rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));          //!< 对残差进行编码并计算RDCost</p><p>  
							encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,(uiNoResidual? true:false));
						    
							getCbfY = (rpcTempCU->m_puhCbf[0][0] & 0x1);
							getCbfU = (rpcTempCU->m_puhCbf[1][0] & 0x1); 
							getCbfV = (rpcTempCU->m_puhCbf[2][0] & 0x1);
							
							isZero_QtRootCbfTemp = ( getCbfY || getCbfU || getCbfV ) == 0;
							
							if ( uiNoResidual == 0 &&  isZero_QtRootCbfTemp)          //!< CBF为0，说明变换系数全为0  
							{
								// If no residual when allowing for one, then set mark to not try case where residual is forced to 0
								mergeCandBuffer[uiMergeCand] = 1;
							}
						  
							//rpcTempCU->setSkipFlagSubParts( isZero_QtRootCbfTemp, 0, uhDepth );
							memset(rpcTempCU->m_skipFlag,isZero_QtRootCbfTemp,uiCurrPartNumb);
							
							//xCheckDQP( rpcTempCU );
							//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth);           //!< 更新最佳模式  
							if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
							{
								TComYuv* pcYuv;
								// Change Information data
								TComDataCU* pcCU = rpcBestCU;
								rpcBestCU = rpcTempCU;
								rpcTempCU = pcCU;

								// Change Prediction data
								pcYuv = pcPredYuvBest;
								pcPredYuvBest = pcPredYuv;
								pcPredYuv = pcYuv;

								// Change Reconstruction data
								pcYuv = pcRecoYuvBest;
								pcRecoYuvBest = pcRecoYuv;
								pcRecoYuv = pcYuv;

								pcYuv = NULL;
								pcCU  = NULL;

								// store temp best CI for next CU coding
								//m_pppcRDSbacCoder[uhDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);	
							}
							
							//rpcTempCU->initEstData( uhDepth, orgQP, bTransquantBypassFlag );     //!< 重新初始化预测参数，为下一次预测做准备
							initEstData_cos(rpcTempCU,uhDepth, rpcTempCU->m_phQP[0], bTransquantBypassFlag);
							
							if( !bestIsSkip )
							{
								getCbfY = (rpcBestCU->m_puhCbf[0][0] & 0x1);
								getCbfU = (rpcBestCU->m_puhCbf[1][0] & 0x1); 
								getCbfV = (rpcBestCU->m_puhCbf[2][0] & 0x1);
							
								isZero_QtRootCbfTemp = ( getCbfY || getCbfU || getCbfV ) == 0;
								
								bestIsSkip = isZero_QtRootCbfTemp; //rpcBestCU->getQtRootCbf(0) == 0;
							}
						}
					}
				}	
			}
			
			//到此Merge模式的最佳CU状态已保存至rpcBestCU，最佳YUV已保存至pcPredYuvBest，临时CU和Yuv空间可以删除了
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuv);
			destoryCurYuv_cos(pcRecoYuv); //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurYuv_cos(pcResiYuv);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcBestCU;
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuvBest;
			
			///////////////////////////////////
			//m_pppcRDSbacCoder[uhNextDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]);
			//////////////////////////////////
			  
				//由于我们是采用split的方式进行8x8块的两种模式，合并之后进行两次编码比较(在encodeRelated_8x8中)，在这里各自修复熵编码器的上下文等到join之后的encodeRelated_8x8中，其实只有一次即encodeRelated_8x8中for循环的第一次得到了修复
				//因此，这里修复没有作用
				//----- restore context models -----
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		
			
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};	
}
	
composite xCheckRDCostInter_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                             input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			
			//UChar uhDepth        = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 0, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 1;
				Int           iNumPredDir = 2;  //B帧
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3] = {3, 3, 5};  // B帧
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2Nx2N;
				PartSize      SIZE_2Nx2N = SIZE_2Nx2N;

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
    
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					//if ( (rpcTempCU->getSlice()->isInterB()) && (rpcTempCU->isBipredRestriction(iPartIdx) == false) )  //只有8x8块的Nx2N,2NxN模式 不满足该条件
					{
					  UInt uiMotBits[2];
					  
					  Int iRefList = (uiCost[0] <= uiCost[1])?1:0;
					  Int iRefIdxTemp = 0;
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  bool bLMvdL1Zero = rpcTempCU->m_pcSlice->m_bLMvdL1Zero;
					  bool bChanged = false;
					  
					  Int iRefStart = 0;
					  Int iRefEnd   = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList]-1;
											
					  cMvBi[0] = cMv[0];            cMvBi[1] = cMv[1];
					  iRefIdxBi[0] = iRefIdx[0];    iRefIdxBi[1] = iRefIdx[1];
					  
					  memcpy(cMvPredBi, cMvPred, sizeof(cMvPred));
					  memcpy(aaiMvpIdxBi, aaiMvpIdx, sizeof(aaiMvpIdx));
					  
					  // if(pcCU->getSlice()->getMvdL1ZeroFlag() )
					  if(bLMvdL1Zero)
					  {
						TComYuv* pcYuvPred = &(m_pcPredSearch->m_acYuvPred[1]);
						Int refNumIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[REF_PIC_LIST_1];
						
						//xCopyAMVPInfo(&aacAMVPInfo[1][bestBiPRefIdxL1], rpcTempCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
						copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][bestBiPRefIdxL1], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						
						//rpcTempCU->setMVPIdxSubParts( bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->getDepth(uiPartAddr));
						setMVPIdxSubParts_cos(rpcTempCU,bestBiPMvpL1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, uhDepth);
						
						aaiMvpIdxBi[1][bestBiPRefIdxL1] = bestBiPMvpL1;
						cMvPredBi[1][bestBiPRefIdxL1]   = (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo).m_acMvCand[bestBiPMvpL1];
						//cMvPredBi[1][bestBiPRefIdxL1]   = &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo)->m_acMvCand[bestBiPMvpL1];

						cMvBi[1] = cMvPredBi[1][bestBiPRefIdxL1];
						iRefIdxBi[1] = bestBiPRefIdxL1;
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllMv( cMvBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						//rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->setAllRefIdx( iRefIdxBi[1], ePartSize, uiPartAddr, 0, iPartIdx );
						
						setAllMv_cos(rpcTempCU, REF_PIC_LIST_1, cMvBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, REF_PIC_LIST_1, iRefIdxBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						
						//motionCompensation( rpcTempCU, pcYuvPred, REF_PIC_LIST_1, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, REF_PIC_LIST_1, pcYuvPred,false);
						
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiMbBits[1];

						if ( refNumIdx > 1 )
						{
						  uiMotBits[1] += bestBiPRefIdxL1+1;
						  if ( bestBiPRefIdxL1 == refNumIdx - 1 ) uiMotBits[1]--;
						}

						uiMotBits[1] += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[1][bestBiPRefIdxL1]][2];

						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];

						cMvTemp[1][bestBiPRefIdxL1] = cMvBi[1];
						
						iRefList = 0;
					 	eRefPicList = REF_PIC_LIST_0;
					  }
					  else
					  {
						uiMotBits[0] = uiBits[0] - uiMbBits[0];
						uiMotBits[1] = uiBits[1] - uiMbBits[1];
						uiBits[2] = uiMbBits[2] + uiMotBits[0] + uiMotBits[1];
						
						setAllMv_cos(rpcTempCU, (RefPicList)(1-iRefList), cMv[1-iRefList], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						setAllRefIdx_cos(rpcTempCU, (RefPicList)(1-iRefList), iRefIdx[1-iRefList], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx );
						xPredInterUni_cos(m_pcPredSearch, rpcTempCU, uiPartAddr, uiWidth, uiHeight, (RefPicList)(1-iRefList), &(m_pcPredSearch->m_acYuvPred[1-iRefList]),false);
					  }
					  
					  for (iRefIdxTemp = iRefStart; iRefIdxTemp <= iRefEnd; iRefIdxTemp++ )
					  {
						  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
						  
						  uiBitsTemp = uiMbBits[2] + uiMotBits[1-iRefList];
						  if ( numRefIdx > 1 )
						  {
							uiBitsTemp += iRefIdxTemp+1;
							if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						  }
						  uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdxBi[iRefList][iRefIdxTemp]][2];
						  
						  // call ME
						  xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPredBi[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp, true );
						  
						  //xCopyAMVPInfo(&aacAMVPInfo[iRefList][iRefIdxTemp], rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo());
						  //xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						 
						  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[iRefList][iRefIdxTemp], &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo));
						  checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPredBi[iRefList][iRefIdxTemp], aaiMvpIdxBi[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						  
						  if ( uiCostTemp < uiCostBi )
						  {
							bChanged = true;
							
							cMvBi[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
							iRefIdxBi[iRefList] = iRefIdxTemp;
							
							uiCostBi            = uiCostTemp;
							uiMotBits[iRefList] = uiBitsTemp - uiMbBits[2] - uiMotBits[1-iRefList];
							uiBits[2]           = uiBitsTemp;
							
						  }
					  } // for loop-iRefIdxTemp
						
					  if ( !bChanged )
					  {
						  if ( uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1] )
						  {
							//xCopyAMVPInfo(&aacAMVPInfo[0][iRefIdxBi[0]], pcCU->getCUMvField(REF_PIC_LIST_0)->getAMVPInfo());
							//xCheckBestMVP(pcCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
							copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[0][iRefIdxBi[0]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_0].m_cAMVPInfo));
						    checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_0, cMvBi[0], cMvPredBi[0][iRefIdxBi[0]], aaiMvpIdxBi[0][iRefIdxBi[0]], uiBits[2], uiCostBi);
						  
							if(!bLMvdL1Zero)
							{
							  //xCopyAMVPInfo(&aacAMVPInfo[1][iRefIdxBi[1]], pcCU->getCUMvField(REF_PIC_LIST_1)->getAMVPInfo());
							  //xCheckBestMVP(pcCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							  copyAMVPInfo_cos(m_pcPredSearch, &aacAMVPInfo[1][iRefIdxBi[1]], &(rpcTempCU->m_acCUMvField[REF_PIC_LIST_1].m_cAMVPInfo));
						      checkBestMVP_cos(m_pcPredSearch, rpcTempCU, REF_PIC_LIST_1, cMvBi[1], cMvPredBi[1][iRefIdxBi[1]], aaiMvpIdxBi[1][iRefIdxBi[1]], uiBits[2], uiCostBi);
							}
						  }
						  break;
					  }
					} // if (B_SLICE)
		
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU);
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
					  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}	
				
				
				
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
						  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
						
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
						  
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						 TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					     TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
					  
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_2Nx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}

					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
    
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			
			}
		
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );

		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite xCheckRDCostInter_Nx2N_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                 input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_Nx2N_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，0
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 2, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，Nx2N模式
				Int           iNumPredDir = 2;  //预测方向的数目，
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth>>1;
				Int			  iRoiHeight = 64>>uhDepth;
			  
				UInt          uiMbBits[3];
				
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_Nx2N;  //
				PartSize      SIZE_Nx2N = SIZE_Nx2N;  

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 2 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 5; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 2);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					
					
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_Nx2N,uiPartAddr,iPartIdx);
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;
					
					if(uiCostBi <= uiCost[0] && uiCostBi <= uiCost[1])
					{
						uiLastMode = 2;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMvBi[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdxBi[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMvBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdxBi[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[0] - cMvPredBi[0][iRefIdxBi[0]];
						TempMv.m_iHor = cMvBi[0].m_iHor - cMvPredBi[0][iRefIdxBi[0]].m_iHor;
					    TempMv.m_iVer = cMvBi[0].m_iVer - cMvPredBi[0][iRefIdxBi[0]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						//TempMv = cMvBi[1] - cMvPredBi[1][iRefIdxBi[1]];
						TempMv.m_iHor = cMvBi[1].m_iHor - cMvPredBi[1][iRefIdxBi[1]].m_iHor;
					    TempMv.m_iVer = cMvBi[1].m_iVer - cMvPredBi[1][iRefIdxBi[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						
						setInterDirSubParts_cos(rpcTempCU,3, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdxBi[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdxBi[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdxBi[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						
						uiMEBits = uiBits[2];
					}	
				
					else if ( uiCost[0] <= uiCost[1] )
					{
						  uiLastMode = 0;
						  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
						   TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					       TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;
					  
						  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						  uiMEBits = uiBits[0];
					
					}
					else
					{
						uiLastMode = 1;
						
						setAllMv_cos(rpcTempCU,REF_PIC_LIST_1,cMv[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_1,iRefIdx[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						//TempMv = cMv[1] - cMvPred[1][iRefIdx[1]];
						TempMv.m_iHor = cMv[1].m_iHor - cMvPred[1][iRefIdx[1]].m_iHor;
					    TempMv.m_iVer = cMv[1].m_iVer - cMvPred[1][iRefIdx[1]].m_iVer;
						
						setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,TempMv, SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						setInterDirSubParts_cos(rpcTempCU,2, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[0]);
						setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[1][iRefIdx[1]], REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);  
						uiMEBits = uiBits[1];
					}
					
					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
						
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,  uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_Nx2N, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
    
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}


composite xCheckRDCostInter_2NxN_8x8(output stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                  input stream<unsigned long ulpcOrigYuv>In)
{
	param UChar uhDepth; 
	
	Out = xCheckRDCostInter_2NxN_8x8(In)
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			TComDataCU *rpcTempCU = NULL;
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv); //从输入获得
			
			TComYuv *pcPredYuv = NULL, *pcRecoYuv = NULL, *pcResiYuv = NULL;
			TComYuv* pcResiYuvBest = NULL;
			
			//UChar uhDepth        = 3;  //当前CU的深度，3
			UInt  uiCurrPartNumb = 256>>(uhDepth<<1);  //getNumPartitions()
			UInt  uiWidth = 64>>uhDepth;
			UInt  uiHeight = 64>>uhDepth;
			
			//TEncTop* m_pcEncTop = (TEncTop*)(In[0].m_ulTEncTop); //将输入转换成有效指针
			//TEncSbac*** m_pppcRDSbacCoder;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			
			double dRdCost = 0.0;
			RefPicList REF_PIC_LIST_0 = REF_PIC_LIST_0;  //对于枚举类型的值，不能直接使用，需要定义相关变量；此处变量名和枚举类型中的枚举值名字相同，是为了和下文匹配
			RefPicList REF_PIC_LIST_1 = REF_PIC_LIST_1;
			
			//开辟临时的CU和YUV
			createCurCU_cos(pcCU,rpcTempCU,uhDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间	createCurCU_cos(pcCU,rpcBestCU,uiDepth,uiAbsZorderIdx);  //创建临时CU空间并初始化 , 注意使用完毕应要销毁空间
			
			createCurYuv_cos(pcPredYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcRecoYuv,uiWidth,uiHeight);   
			createCurYuv_cos(pcResiYuv,uiWidth,uiHeight);  
			createCurYuv_cos(pcResiYuvBest,uiWidth,uiHeight); //创建原始YUV空间并初始化，注意释放空间
			
			
			uiAbsZorderIdx += uiCurrPartNumb;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			//rpcTempCU->setDepthSubParts( uhDepth, 0 );
			//rpcTempCU->setSkipFlagSubParts( false, 0, uhDepth );
			//rpcTempCU->setPartSizeSubParts  ( ePartSize,  0, uhDepth );
			//rpcTempCU->setPredModeSubParts  ( MODE_INTER, 0, uhDepth );
			
			memset( rpcTempCU->m_puhDepth, uhDepth, sizeof(UChar)*uiCurrPartNumb );
			memset( rpcTempCU->m_skipFlag, false, uiCurrPartNumb);
			memset( rpcTempCU->m_pePartSize, 1, uiCurrPartNumb);
			memset( rpcTempCU->m_pePredMode, 0, uiCurrPartNumb );
				
			//m_pcPredSearch->predInterSearch ( rpcTempCU, m_ppcOrigYuv[uhDepth], m_ppcPredYuvTemp[uhDepth], m_ppcResiYuvTemp[uhDepth], m_ppcRecoYuvTemp[uhDepth] );
			{
				TComMv        cMvSrchRngLT;
				TComMv        cMvSrchRngRB;
			  
				TComMv        cMvZero;
				TComMv        TempMv; //kolya
  
				TComMv        cMv[2];
				TComMv        cMvBi[2];
				TComMv        cMvTemp[2][33];
  
				Int           iNumPart    = 2;  //划分为2个，2NxN模式
				Int           iNumPredDir = 2;  //预测方向的数目，对于lowdey_p帧，只有前向参考帧，即只参考List0
  
				TComMv        cMvPred[2][33];
			  
				TComMv        cMvPredBi[2][33];
				Int           aaiMvpIdxBi[2][33];
			  
				Int           aaiMvpIdx[2][33];
				Int           aaiMvpNum[2][33];
			  
				AMVPInfo aacAMVPInfo[2][33];
			  
				Int           iRefIdx[2]={0,0}; //If un-initialized, may cause SEGV in bi-directional prediction iterative stage.
				Int           iRefIdxBi[2];
			  
				UInt          uiPartAddr = 0;
				Int           iRoiWidth  = 64>>uhDepth;   //2NxN模式的子块宽
				Int			  iRoiHeight = 64>>uhDepth>>1;     //2NxN模式的子块高
			  
				UInt          uiMbBits[3];  //不同帧类型，不同划分对应不同的值
			  
				UInt          uiLastMode = 0;
				Int           iRefStart, iRefEnd;
			  
				//PartSize      ePartSize = SIZE_2NxN;  //
				PartSize      SIZE_2NxN = SIZE_2NxN;  //

				Int           bestBiPRefIdxL1 = 0;
				Int           bestBiPMvpL1 = 0;
				UInt          biPDistTemp = MAX_INT;


				TComMvField cMvFieldNeighbours[10]; // double length for mv of both lists
				UChar uhInterDirNeighbours[5];
				Int numValidMergeCand = 0 ;
				Int iPartIdx = 0;
				
				//Yuv空间的清理
				predInterYuvClear_cos(m_pcPredSearch, pcPredYuv, pcRecoYuv, pcResiYuv);
				
				for (iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				{
					UInt          uiCost[2] = { MAX_UINT, MAX_UINT };
					UInt          uiCostBi  =   MAX_UINT;
					UInt          uiCostTemp;
    
					UInt          uiBits[3];
					UInt          uiBitsTemp;

					UInt          bestBiPDist = MAX_INT;

					UInt          uiCostTempL0[16];
					Int iNumRef = 0;
					Int iRefList = 0;
					Int iRefIdxTemp = 0;
					
					UInt          uiBitsTempL0[16];

					TComMv        mvValidList1;
					Int           refIdxValidList1 = 0;
					UInt          bitsValidList1 = MAX_UINT;
					UInt          costValidList1 = MAX_UINT;
					
					
					UInt uiMEBits = 0;
					
					for (iNumRef=0; iNumRef < 16; iNumRef++)
					{
						uiCostTempL0[iNumRef] = MAX_UINT;
					}
					
					//xGetBlkBits( ePartSize, rpcTempCU->getSlice()->isInterP(), iPartIdx, uiLastMode, uiMbBits);
					if(iPartIdx == 0)
					{
						if(uiLastMode == 0) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 3;}
						if(uiLastMode == 1) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
						if(uiLastMode == 2) {uiMbBits[0] = 0; uiMbBits[1] = 0 ; uiMbBits[2] = 0;}
					}
					
					else
					{
						if(uiLastMode == 0) {uiMbBits[0] = 5; uiMbBits[1] = 7 ; uiMbBits[2] = 7;}
						if(uiLastMode == 1) {uiMbBits[0] = 7; uiMbBits[1] = 5 ; uiMbBits[2] = 7;}
						if(uiLastMode == 2) {uiMbBits[0] = 6; uiMbBits[1] = 6 ; uiMbBits[2] = 6;}
						
					}
					
					//rpcTempCU->getPartIndexAndSize( iPartIdx, uiPartAddr, iRoiWidth, iRoiHeight );
					uiPartAddr = ( iPartIdx == 0 )? 0 : (uiCurrPartNumb >> 1);
    
					//  Uni-directional prediction
					for (iRefList = 0; iRefList < iNumPredDir; iRefList++ )
					{
					  RefPicList  eRefPicList = ( iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0 );
					  Int numRefIdx = rpcTempCU->m_pcSlice->m_aiNumRefIdx[eRefPicList];
					  
					  for (iRefIdxTemp = 0; iRefIdxTemp < numRefIdx; iRefIdxTemp++ )
					  {
						Int tmp = 0;
						
						uiBitsTemp = uiMbBits[iRefList];
						if ( numRefIdx > 1 )
						{
						  uiBitsTemp += iRefIdxTemp+1;
						  if ( iRefIdxTemp == numRefIdx-1 ) uiBitsTemp--;
						}

						//xEstimateMvPredAMVP( rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						xEstimateMvPredAMVP_cos( m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, iRefIdxTemp, cMvPred[iRefList][iRefIdxTemp], false, &biPDistTemp);
						
						aaiMvpIdx[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPIdx[eRefPicList][uiPartAddr];//rpcTempCU->getMVPIdx(eRefPicList, uiPartAddr);
						aaiMvpNum[iRefList][iRefIdxTemp] = rpcTempCU->m_apiMVPNum[eRefPicList][uiPartAddr];//rpcTempCU->getMVPNum(eRefPicList, uiPartAddr);

						if(rpcTempCU->m_pcSlice->m_bLMvdL1Zero && iRefList==1 && biPDistTemp < bestBiPDist)
						{
						  bestBiPDist = biPDistTemp;
						  bestBiPMvpL1 = aaiMvpIdx[iRefList][iRefIdxTemp];
						  bestBiPRefIdxL1 = iRefIdxTemp;
						}
						
						uiBitsTemp += m_pcPredSearch->m_auiMVPIdxCost[aaiMvpIdx[iRefList][iRefIdxTemp]][2];
				
						if ( iRefList == 1 )    // list 1
						{
						  //Int tmp =  rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						  tmp = rpcTempCU->m_pcSlice->m_list1IdxToList0Idx[iRefIdxTemp];
						 
						  if ( tmp >= 0 )
						  {
							cMvTemp[1][iRefIdxTemp] = cMvTemp[0][tmp];
							uiCostTemp = uiCostTempL0[tmp];
							//first subtract the bit-rate part of the cost of the other list//
							//uiCostTemp -= m_pcRdCost->getCost( uiBitsTempL0[tmp] );
							uiCostTemp -= ( (m_pcRdCost->m_uiCost) * uiBitsTempL0[tmp] )>>16;
							//correct the bit-rate part of the current ref//
							//m_pcRdCost->setPredictor  ( cMvPred[iRefList][iRefIdxTemp] );
							m_pcRdCost->m_mvPredictor = cMvPred[iRefList][iRefIdxTemp];
							
							//uiBitsTemp += m_pcRdCost->getBits( cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer );
							uiBitsTemp += getBitsRdCost_cos(m_pcRdCost,cMvTemp[1][iRefIdxTemp].m_iHor, cMvTemp[1][iRefIdxTemp].m_iVer);
							
							//calculate the correct cost
							uiCostTemp += ((m_pcRdCost->m_uiCost) * uiBitsTemp) >> 16;
						  }
						  else
						  {
							xMotionEstimation_cos (m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						  }
						}
						else
						{
						  xMotionEstimation_cos (m_pcPredSearch,rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp );
						}
						
						//xMotionEstimation_cos( m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, eRefPicList, &cMvPred[iRefList][iRefIdxTemp], iRefIdxTemp, cMvTemp[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp ,false );
			
						copyAMVPInfo_cos(m_pcPredSearch, &(rpcTempCU->m_acCUMvField[eRefPicList].m_cAMVPInfo) , &aacAMVPInfo[iRefList][iRefIdxTemp]);
						
						checkBestMVP_cos(m_pcPredSearch, rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);
						//xCopyAMVPInfo(rpcTempCU->getCUMvField(eRefPicList)->getAMVPInfo(), &aacAMVPInfo[iRefList][iRefIdxTemp]); // must always be done ( also when AMVP_MODE = AM_NONE )
						//xCheckBestMVP(rpcTempCU, eRefPicList, cMvTemp[iRefList][iRefIdxTemp], cMvPred[iRefList][iRefIdxTemp], aaiMvpIdx[iRefList][iRefIdxTemp], uiBitsTemp, uiCostTemp);

						if ( iRefList == 0 )
						{
						  uiCostTempL0[iRefIdxTemp] = uiCostTemp;
						  uiBitsTempL0[iRefIdxTemp] = uiBitsTemp;
						}
						if ( uiCostTemp < uiCost[iRefList] )
						{
						  uiCost[iRefList] = uiCostTemp;
						  uiBits[iRefList] = uiBitsTemp; // storing for bi-prediction

						  // set motion
						  cMv[iRefList]     = cMvTemp[iRefList][iRefIdxTemp];
						  iRefIdx[iRefList] = iRefIdxTemp;
						}
						
						if ( iRefList == 1 && uiCostTemp < costValidList1 && tmp < 0 )
						{
						  costValidList1 = uiCostTemp;
						  bitsValidList1 = uiBitsTemp;

						  // set motion
						  mvValidList1     = cMvTemp[iRefList][iRefIdxTemp];
						  refIdxValidList1 = iRefIdxTemp;
						}
					  }
					}
    
					//  Bi-directional prediction
					
				
					//  Clear Motion Field
					clearMvField_cos(rpcTempCU,SIZE_2NxN,uiPartAddr,iPartIdx);
					
					
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					
					
					// Set Motion Field_
					cMv[1] = mvValidList1;
					iRefIdx[1] = refIdxValidList1;
					uiBits[1] = bitsValidList1;
					uiCost[1] = costValidList1;

					if ( uiCost[0] <= uiCost[1] )
					{
					  uiLastMode = 0;
					  setAllMv_cos(rpcTempCU,REF_PIC_LIST_0,cMv[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  setAllRefIdx_cos(rpcTempCU,REF_PIC_LIST_0,iRefIdx[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  //TempMv = cMv[0] - cMvPred[0][iRefIdx[0]];
					  TempMv.m_iHor = cMv[0].m_iHor - cMvPred[0][iRefIdx[0]].m_iHor;
					  TempMv.m_iVer = cMv[0].m_iVer - cMvPred[0][iRefIdx[0]].m_iVer;

					  setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,TempMv, SIZE_2NxN, uiPartAddr, 0, iPartIdx);
					  setInterDirSubParts_cos(rpcTempCU,1, uiPartAddr, iPartIdx,rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPIdxSubParts_cos(rpcTempCU,aaiMvpIdx[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  setMVPNumSubParts_cos(rpcTempCU,aaiMvpNum[0][iRefIdx[0]], REF_PIC_LIST_0,uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
					  uiMEBits = uiBits[0];
					
					}

					//当划分size不等于2Nx2N模式时
					{
						UInt uiMRGInterDir = 0;     
						TComMvField cMRGMvField[2];
						UInt uiMRGIndex = 0;

						UInt uiMEInterDir = 0;
						TComMvField cMEMvField[2];
						 
						// calculate ME cost
						UInt uiMEError = MAX_UINT;
						UInt uiMECost = 0;
						// find Merge result
						UInt uiMRGCost = MAX_UINT;
						
						m_pcRdCost->m_uiCost = m_pcRdCost->m_uiLambdaMotionSAD ;
						xGetInterPredictionError_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMEError, true);
						uiMECost = uiMEError + ((m_pcRdCost->m_uiCost) * uiMEBits) >> 16;
						 // save ME result.
						uiMEInterDir = rpcTempCU->m_puhInterDir[uiPartAddr];
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_0, cMEMvField[0] );
						getMvField_cos( rpcTempCU, uiPartAddr, REF_PIC_LIST_1, cMEMvField[1] );

						
						xMergeEstimation_cos(m_pcPredSearch, rpcTempCU, pcOrigYuv, iPartIdx, uiMRGInterDir, cMRGMvField, uiMRGIndex, uiMRGCost, cMvFieldNeighbours, uhInterDirNeighbours, numValidMergeCand);
						
						if ( uiMRGCost < uiMECost )
						{
							// set Merge result
							
							setMergeFlagSubParts_cos(rpcTempCU, true, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMergeIndexSubParts_cos(rpcTempCU,uiMRGIndex,    uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMRGMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMRGMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_0,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvd_cos(rpcTempCU,REF_PIC_LIST_1,cMvZero,SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							
							
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_0, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPIdxSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setMVPNumSubParts_cos(rpcTempCU,-1, REF_PIC_LIST_1, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
						
						}
						else
						{
							// set ME result
							
							setMergeFlagSubParts_cos(rpcTempCU, false, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setInterDirSubParts_cos(rpcTempCU,uiMRGInterDir, uiPartAddr, iPartIdx, rpcTempCU->m_puhDepth[uiPartAddr]);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_0,cMEMvField[0], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
							setAllMvField_cos(rpcTempCU,REF_PIC_LIST_1,cMEMvField[1], SIZE_2NxN, uiPartAddr, 0, iPartIdx);
						}
					}
					
					//  MC
					//motionCompensation ( rpcTempCU, rpcPredYuv, REF_PIC_LIST_X, iPartIdx );
					{
						if ( xCheckIdenticalMotion_cos( m_pcPredSearch, pcCU, uiPartAddr ) )
						{
							xPredInterUni_cos (m_pcPredSearch, pcCU, uiPartAddr, iRoiWidth, iRoiHeight, REF_PIC_LIST_0, pcPredYuv );
						}
						else
						{
							//xPredInterBi(pcCU, uiPartAddr, iWidth, iHeight, pcPredYuv );
							Int  iRefList = 0;
								
							TComYuv* pcMbYuv;
							Int iRefIdx[2] = {-1,-1};
							for (iRefList = 0; iRefList < 2; iRefList++ )
							{
								RefPicList eRefPicList = (iRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
								//iRefIdx[iRefList] = rpcTempCU->getCUMvField( eRefPicList )->getRefIdx( uiPartAddr );
								//iRefIdx[iRefList] = &(rpcTempCU->m_acCUMvField[eRefPicList])->m_piRefIdx[uiPartAddr];
								iRefIdx[iRefList] = (rpcTempCU->m_acCUMvField[eRefPicList]).m_piRefIdx[uiPartAddr];
								if ( iRefIdx[iRefList] < 0 )
								{
									continue;
								}

								//assert( iRefIdx[iRefList] < rpcTempCU->getSlice()->getNumRefIdx(eRefPicList) );

								pcMbYuv = &(m_pcPredSearch->m_acYuvPred[iRefList]);
								//if( rpcTempCU->getCUMvField( REF_PIC_LIST_0 )->getRefIdx( uiPartAddr ) >= 0 && rpcTempCU->getCUMvField( REF_PIC_LIST_1 )->getRefIdx( uiPartAddr ) >= 0 )
								if( (rpcTempCU->m_acCUMvField[REF_PIC_LIST_0]).m_piRefIdx[uiPartAddr] >= 0 && (rpcTempCU->m_acCUMvField[REF_PIC_LIST_1]).m_piRefIdx[uiPartAddr] >= 0 )
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, true );
								}
								else
								{
									xPredInterUni_cos( m_pcPredSearch, rpcTempCU, uiPartAddr, iRoiWidth, iRoiHeight, eRefPicList, pcMbYuv, false );
								}
							}
							xWeightedAverage_cos( m_pcPredSearch, iRefIdx[0], iRefIdx[1], uiPartAddr, iRoiWidth, iRoiHeight, pcPredYuv );
						}
					}
				} //  end of for ( Int iPartIdx = 0; iPartIdx < iNumPart; iPartIdx++ )
				
				(m_pcPredSearch->m_cDistParam).bApplyWeight = false;	
			}
			
			
			
			//m_pcPredSearch->encodeResAndCalcRdInterCU( rpcTempCU, pcOrigYuv, pcPredYuv, pcResiYuv, pcResiYuvBest, pcRecoYuv, false );
			encodeResAndCalcRdInterCU_cos(m_pcPredSearch,rpcTempCU,pcOrigYuv,pcPredYuv,pcResiYuv,pcResiYuvBest,pcRecoYuv,false);
			
			//rpcTempCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcTempCU->getTotalBits(), rpcTempCU->getTotalDistortion() );
			dRdCost = ((Double)rpcTempCU->m_uiTotalDistortion + (Double)((Int)(rpcTempCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcTempCU->m_dTotalCost = dRdCost;
			
			//xCheckDQP( rpcTempCU );
			//xCheckBestMode(rpcBestCU, rpcTempCU, uhDepth); 此处不需要比较，待到合并时一起比较
			
			//删除相应空间
			destoryCuYuv_cos(pcResiYuvBest);
			
			Out[0].ulpcTempCU  =  (unsigned long)rpcTempCU;	
			Out[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out[0].ulpcPredYuv = (unsigned long)pcPredYuv;
			Out[0].ulpcRecoYuv = (unsigned long)pcRecoYuv;
			Out[0].ulpcResiYuv = (unsigned long)pcResiYuv;
			
			
			////////////////////////////////////熵编码器状态加载
			//m_pppcRDSbacCoder[uhDepth][CI_CURR_BEST]->load(m_pppcRDSbacCoder[uhDepth][CI_NEXT_BEST]);
			////////////////////////////////////
			
				  
				//----- restore context models -----//道理同上
				//load_cos(m_pcPredSearch->m_pcRDGoOnSbacCoder,m_pcPredSearch->m_pppcRDSbacCoder[uhDepth][0] );
		}
		window
		{
			In sliding(1,1);
			Out tumbling(1);
		}
	};
}

composite encodeRelated_8x8(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
							 input stream<unsigned long ulpcTempCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>In)
{
	Out = encodeRelated_8x8(In)
	{
		int uiPartUnitIdx;  //记录处理的个数
		init
		{
			uiPartUnitIdx = 0;
		}
		work
		{
			
			UInt uiDepth = 3; //rpcTempCU_F-> m_puhDepth[0];  
			double dRdCost;
			int i = 0;
			TComDataCU *rpcBestCU = (TComDataCU *)(In[0].ulpcTempCU);  //从Merge处的分支的输入得来的最佳
			TComYuv *pcOrigYuv = (TComYuv *)(In[0].ulpcOrigYuv);  
			TComYuv *pcPredYuvBest = (TComYuv *)(In[0].ulpcPredYuv);  //从Merge处的分支得来的最佳
			TComYuv *pcRecoYuvBest = (TComYuv *)(In[0].ulpcRecoYuv);
			TComYuv *pcResiYuvBest = (TComYuv *)(In[0].ulpcResiYuv);
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			//initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&(m_pcEncTop->m_cEntropyCoder),m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			for(i = 1; i < 4; i++)
			{
				TComDataCU* rpcTempCU = (TComDataCU *)(In[i].ulpcTempCU);
				TComYuv *pcPredYuvTemp = (TComYuv *)(In[i].ulpcPredYuv);
				TComYuv *pcRecoYuvTemp = (TComYuv *)(In[i].ulpcRecoYuv);
				TComYuv *pcResiYuvTemp = (TComYuv *)(In[i].ulpcResiYuv);
				
				
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
					
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp); //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurYuv_cos(pcResiYuvTemp);
			}
			//原始Yuv删除
			destoryCuYuv_cos(pcOrigYuv);
			
			//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
			
			//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
			if(++uiPartUnitIdx == 4)  
			{
				//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
				uiPartUnitIdx = 0;
			}
			
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;
				
			copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

			xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth);    //至此，一个8x8块的计算全部完成
			
			Out[0].ulpcBestCU = (unsigned long)rpcBestCU;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
		}
		window
		{
			In sliding(4,4);   //输入为4种模式的临时CU
			Out tumbling(1);  //输出一个最佳的8x8块
		}
	};
}

composite xCheckRDCostInter8x8_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                                    input stream<unsigned long ulpcOrigYuv>In)
{	
	stream<unsigned long ulpcTempCU,unsigned long ulpcOrigYuv, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out2;
	Out2 = splitjoin(In)
	{
		int i;
		UChar uhDepth = 3;
		split duplicate(1);
		for(i=0; i<4; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge_8x8(uhDepth);  //8x8块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter_8x8(uhDepth);  //8x8块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N_8x8(uhDepth);  //8x8块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN_8x8(uhDepth);  //8x8块的2N*N模式
		}	
		join roundrobin(1);		
	};
	Out = encodeRelated_8x8(Out2)();  //输出一个最佳的8x8块
}


//将某一8*8最终的CU状态及YUV拷贝至上一层16*16 CU的相应位置,也即16*16的分割模式
composite copyPartTo_16x16(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_16x16(In)
	{
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的16x16块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_16x16;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 2;
			uhWidth  = 16;
			uhHeight = 16;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_16x16 = NULL;  //
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
	        //pcCU为LCU的指针
			
			TComPic* pcPic = pcCU->m_pcPic;
			TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			
			int y;
			Pel* pDst, *pDstU, *pDstV;
			Pel* pSrc, *pSrcU, *pSrcV;
			UInt iDstStride, iSrcStride,iWidth,iCWidth;
			
			UInt iCuAddr = pcCU->m_uiCUAddr;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0; 
			
			//从 encodeRelated_8x8 的输出得到的最佳块的信息;待完成
			TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);
			TComYuv *pcPredYuvBest_8x8 = (TComYuv *)(In[0].ulpcPredYuvBest);
			TComYuv *pcRecoYuvBest_8x8 = (TComYuv *)(In[0].ulpcRecoYuvBest); 
			TComYuv *pcResiYuvBest_8x8 = (TComYuv *)(In[0].ulpcResiYuvBest);  //根据输入完成
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			if(uiPartUnitIdx == 0)  //说明是在处理一个新的16x16块
			{	
				createCurCU_cos(pcCU,rpcBestCU_16x16,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
				
				createCurYuv_cos(pcOrigYuv,16,16);  //创建原始YUV空间并初始化，注意释放空间
				
				
				createCurYuv_cos(pcPredYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
				
				createCurYuv_cos(pcRecoYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
		
				createCurYuv_cos(pcResiYuvBest,16,16);//创建原始YUV空间并初始化，注意释放空间
				
				//pcOrigYuv 原始yuv数据拷贝
				//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
			    {
					int  y;
					short* pDst  = pcOrigYuv->m_apiBufY; 
					short* pDstU = pcOrigYuv->m_apiBufU;
					short* pDstV = pcOrigYuv->m_apiBufV;
					//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
					Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					
					//copyFromPicLuma
					UInt  iDstStride  =  pcOrigYuv->m_iWidth;
					UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
					UInt  iWidth = pcOrigYuv->m_iWidth;
					UInt  iCWidth = pcOrigYuv->m_iCWidth;
					for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
					{
						memcpy( pDst, pSrc, sizeof(short)*iWidth);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					//copyFromPicChroma
					iDstStride = pcOrigYuv->m_iCWidth;
					iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
					for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					} 				
				}
				
				uiAbsZorderIdx += 16;  //每处理完一个16x16块，Zorder自增16;
				if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
			}
			
			//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
			//rpcBestCU_16x16->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
			copyPartFrom_cos(rpcBestCU_16x16,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
			
			//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
			{
				
				//计算第uiPartUnitIdx个8x8子块在16x16块中对应位置
				UInt uiDstPartIdx = 4*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
				
				pSrc  = pcRecoYuvBest_8x8->m_apiBufY;
				pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
				
				pSrcU = pcRecoYuvBest_8x8->m_apiBufU;
				pSrcV = pcRecoYuvBest_8x8->m_apiBufV;
				pDstU =     pcRecoYuvBest->m_apiBufU + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
				pDstV =     pcRecoYuvBest->m_apiBufV + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
  
				iSrcStride = pcRecoYuvBest_8x8->m_iWidth;
				iDstStride =     pcRecoYuvBest->m_iWidth;
				
				y = pcRecoYuvBest_8x8->m_iHeight;
				for( y; y!=0; y-- )
				{
					memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
					pDst += iDstStride;
					pSrc += iSrcStride;
				}
				
				iSrcStride = pcRecoYuvBest_8x8->m_iCWidth;
				iDstStride =     pcRecoYuvBest->m_iCWidth;
				
				y = pcRecoYuvBest_8x8->m_iCHeight;
				for ( y; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				}	
			}
			
			//最佳8x8块已拷贝结束，可销毁CU和YUV空间
			destoryCurCU_cos(pcSubBestPartCU);
			destoryCurYuv_cos(pcPredYuvBest_8x8);
			destoryCurYuv_cos(pcRecoYuvBest_8x8);
			destoryCurYuv_cos(pcResiYuvBest_8x8);  //删除临时16x16 CU开辟的空间;并置指针为NULL，
			
			if(++uiPartUnitIdx == 4) //4个8x8块均接收到，对临时最佳16x16块编码
			{
				uiPartUnitIdx = 0; //重置0，用于标记下一个16x16块的开始
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_16x16, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU_16x16->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU_16x16->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_16x16->getTotalBits(), rpcBestCU_16x16->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU_16x16->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_16x16->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU_16x16->m_dTotalCost = dRdCost;
			
				//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
				//xCheckBestMode( rpcBestCU_16x16, rpcTempCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
			}

			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_16x16;	
			Out[0].ulpcOrigYuv = (unsigned long)pcOrigYuv;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
			
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的8x8并将其拷贝至16x16的相应位置
			Out tumbling(1);
		}	
	};
}

//16x16块的帧间预测
composite xCheckRDCostInter16x16_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
									  input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest> Out1;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out2;
	Out1 = getAllSubCu_16x16(In)  //获取4个最佳的8x8块
	{
		work
		{   
			//输出由4个8x8块组成的临时最佳16x16 CU，最佳YUV 地址
			Out1[0].ulpcBestCU  = In[0].ulpcBestCU;	
			Out1[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out1[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out1[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out1[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;
		}
		window
		{
			In sliding(4,4);
			Out1 tumbling(1);
		}
	};
	Out2 = splitjoin(Out1)
	{
		UChar uhDepth = 2;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //16x16块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //16x16块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //16x16块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //16x16块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //16x16块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //16x16块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //16x16块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //16x16块的nRx2N模式
		}	
		join roundrobin(1);
	};
	Out = encodeRelated_16x16(Out2)
	{
		int uiPartUnitIdx;  //记录处理的个数
		init
		{
			uiPartUnitIdx = 0;
		}
		work
		{
			UInt uiDepth = 2; //rpcTempCU_F-> m_puhDepth[0];  
			double dRdCost;
			int i = 0;
			
			//rpcBestCU 用于保存各种模式中的最佳，并未开辟空间,初始设为从join的第一个分支，即Merge处得到的最佳
			TComDataCU* rpcBestCU  = (TComDataCU*)(Out2[0].ulpcTempCU);  // In[0]  
			TComYuv *pcOrigYuv = (TComYuv *)(Out2[0].ulpcOrigYuv); 
			TComYuv *pcPredYuvBest = (TComYuv *)(Out2[0].ulpcPredYuv);  //Merge模式的最佳预测
			TComYuv *pcRecoYuvBest = (TComYuv *)(Out2[0].ulpcRecoYuv);  //Merge模式的最佳
			TComYuv *pcResiYuvBest = (TComYuv *)(Out2[0].ulpcResiYuv);  //Merge模式的最佳
			
			TComDataCU* rpcTempCU;
			TComYuv *pcPredYuvTemp, *pcRecoYuvTemp, *pcResiYuvTemp;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			//initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&(m_pcEncTop->m_cEntropyCoder),m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			for(i = 1; i < 8; i++)  //将从Merge处的最佳和其他7种分割模式比较得到最佳
			{
				rpcTempCU = (TComDataCU*)(Out2[i].ulpcTempCU);
				pcPredYuvTemp = (TComYuv *)(Out2[i].ulpcPredYuv);
				pcRecoYuvTemp = (TComYuv *)(Out2[i].ulpcRecoYuv);
				pcResiYuvTemp = (TComYuv *)(Out2[i].ulpcResiYuv);
				
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
					
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);  //删除临时CU开辟的空间;并置指针为NULL，
			}
			
			//删除原始Yuv
			destoryCurYuv_cos(pcOrigYuv);
			
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;  
		    /////////////到此，8种模式的最佳CU 获取
			
			
			rpcTempCU = (TComDataCU*)(Out2[0].ulpcBestCU);      //从4个8x8子块得到临时最佳CU
			pcPredYuvTemp = (TComYuv *)(Out2[0].ulpcPredYuvBest);  //从4个8x8子块得到临时最佳
			pcRecoYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //从4个8x8子块得到临时最佳
			pcResiYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //从4个8x8子块得到临时最佳
			
			//将8种模式的最佳和分割模式最佳比较 xCheckBestMode
			if( rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
			{
				TComYuv* pcYuv;
				// Change Information data
				TComDataCU* pcCU = rpcBestCU;
				rpcBestCU = rpcTempCU;
				rpcTempCU = pcCU;

				// Change Prediction data
				pcYuv = pcPredYuvBest;
				pcPredYuvBest = pcPredYuvTemp;
				pcPredYuvTemp = pcYuv;

				// Change Reconstruction data
				pcYuv = pcRecoYuvBest;
				pcRecoYuvBest = pcRecoYuvTemp;
				pcRecoYuvTemp = pcYuv;

				pcYuv = NULL;
				pcCU  = NULL;

				// store temp best CI for next CU coding
				//m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_NEXT_BEST]);
			}
			//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuvTemp);
			destoryCurYuv_cos(pcRecoYuvTemp);
			destoryCurYuv_cos(pcResiYuvTemp) ;
			
			//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[3][1]状态已经完成，下一个8x8块可以进行  //通过互斥变量看能否实现
			
			//同时当4个8X8子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
			if(++uiPartUnitIdx == 4)  
			{
				//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
				uiPartUnitIdx = 0;
			}
			
			
			//计算最佳CU的代价值，并拷贝至Yuv
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;
				
			copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

			xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth);    //至此，一个16x16块的计算全部完成
			
			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
		}
		window
		{
			Out2 sliding(8,8);  //输入为 join的8个分支
			Out tumbling(1);   //输出为1个最佳的16x16块
		}
	};
}

//将某一16x16最终的CU状态及YUV拷贝至上一层32x32 CU的相应位置,也即32x32的分割模式
composite copyPartTo_32x32(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_32x32(In)
	{
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的32x32块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_32x32;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 1;
			uhWidth  = 32;
			uhHeight = 32;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_32x32 = NULL;  
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
	        //pcCU为LCU的指针
			
			TComPic* pcPic = pcCU->m_pcPic;
			TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			
			int y;
			Pel* pDst, *pDstU, *pDstV;
			Pel* pSrc, *pSrcU, *pSrcV;
			UInt iDstStride, iSrcStride,iWidth,iCWidth;
			
			UInt iCuAddr = pcCU->m_uiCUAddr;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0; 
			
			//从 encodeRelated_16x16 的输出得到的最佳块的信息;待完成
			TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);	
			TComYuv *pcPredYuvBest_16x16 = (TComYuv *)(In[0].ulpcPredYuvBest);
			TComYuv *pcRecoYuvBest_16x16 = (TComYuv *)(In[0].ulpcRecoYuvBest);
			TComYuv *pcResiYuvBest_16x16 = (TComYuv *)(In[0].ulpcResiYuvBest); //根据输入完成
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			if(uiPartUnitIdx== 0)  //说明是在处理一个新的32x32块
			{	
				createCurCU_cos(pcCU,rpcBestCU_32x32,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
	
				createCurYuv_cos(pcOrigYuv,32,32);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcPredYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcRecoYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,32,32);//创建原始YUV空间并初始化，注意释放空间
				
				//pcOrigYuv 原始yuv数据拷贝
				//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
			    {
					int  y;
					short* pDst  = pcOrigYuv->m_apiBufY; 
					short* pDstU = pcOrigYuv->m_apiBufU;
					short* pDstV = pcOrigYuv->m_apiBufV;
					//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
					Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					
					//copyFromPicLuma
					UInt  iDstStride  =  pcOrigYuv->m_iWidth;
					UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
					UInt  iWidth = pcOrigYuv->m_iWidth;
					UInt  iCWidth = pcOrigYuv->m_iCWidth;
					for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
					{
						memcpy( pDst, pSrc, sizeof(short)*iWidth);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					//copyFromPicChroma
					iDstStride = pcOrigYuv->m_iCWidth;
					iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
					for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					} 				
				}
				
				uiAbsZorderIdx += 64;  //每处理完一个32x32块，Zorder自增64;
			}
			
			//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
			//rpcBestCU_16x16->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
			copyPartFrom_cos(rpcBestCU_32x32,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
			
			//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
			{
				
				//计算第uiPartUnitIdx个16x16子块在32x32块中对应位置
				UInt uiDstPartIdx = 16*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
				
				pSrc  = pcRecoYuvBest_16x16->m_apiBufY;
				pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
				
				pSrcU = pcRecoYuvBest_16x16->m_apiBufU;
				pSrcV = pcRecoYuvBest_16x16->m_apiBufV;
				pDstU =     pcRecoYuvBest->m_apiBufU + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
				pDstV =     pcRecoYuvBest->m_apiBufV + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
  
				iSrcStride = pcRecoYuvBest_16x16->m_iWidth;
				iDstStride =     pcRecoYuvBest->m_iWidth;
				
				y = pcRecoYuvBest_16x16->m_iHeight;
				for( y; y!=0; y-- )
				{
					memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
					pDst += iDstStride;
					pSrc += iSrcStride;
				}
				
				iSrcStride = pcRecoYuvBest_16x16->m_iCWidth;
				iDstStride =     pcRecoYuvBest->m_iCWidth;
				
				y = pcRecoYuvBest_16x16->m_iCHeight;
				for ( y; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				}	
			}
			
			//最佳8x8块已拷贝结束，可销毁CU和YUV空间
			destoryCurCU_cos(pcSubBestPartCU);
			destoryCurYuv_cos(pcPredYuvBest_16x16);
			destoryCurYuv_cos(pcRecoYuvBest_16x16);
			destoryCurYuv_cos(pcResiYuvBest_16x16);
			
			if(++uiPartUnitIdx == 4) //4个16x16块均接收到，对临时最佳32x32块编码
			{
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_32x32, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU_32x32->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU_32x32->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_32x32->getTotalBits(), rpcBestCU_32x32->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU_32x32->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_32x32->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU_32x32->m_dTotalCost = dRdCost;
			
				//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
				//xCheckBestMode( rpcBestCU_32x32, rpcTempCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
			}	
			
			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_32x32;	
			Out[0].ulpcOrigYuv =  (unsigned long)pcOrigYuv;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
			
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的16x16并将其拷贝至32的相应位置
			Out tumbling(1);
		}	
	};
}

//32x32块的帧间预测
composite xCheckRDCostInter32x32_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                                      input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest> Out1;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out2;
		   
	Out1 = getAllSubCu_32x32(In)  //获取4个最佳的16x16块
	{
		work
		{   
			//输出由4个 16x16 块组成的临时最佳 32x32 CU，最佳YUV 地址
			Out1[0].ulpcBestCU  = In[0].ulpcBestCU;	
			Out1[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out1[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out1[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out1[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;	
		}
		window
		{
			In sliding(4,4);
			Out1 tumbling(1);
		}
	};
	Out2 = splitjoin(Out1)
	{
		UChar uhDepth = 1;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //32x32 块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //32x32 块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //32x32 块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //32x32 块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //32x32 块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //32x32 块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //32x32 块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //32x32 块的nRx2N模式
		}	
		join roundrobin(1);
	};
	Out = encodeRelated_32x32(Out2)
	{
		int uiPartUnitIdx;  //记录处理的个数
		init
		{
			uiPartUnitIdx = 0;
		}
		work
		{
			
			UInt uiDepth = 1; //rpcTempCU_F-> m_puhDepth[0];  
			double dRdCost;
			int i = 0;
			
			//rpcBestCU 用于保存各种模式中的最佳，并未开辟空间,初始设为从join的第一个分支，即Merge处得到的最佳
			TComDataCU* rpcBestCU  = (TComDataCU*)(Out2[0].ulpcTempCU);  // Out2[0]  
			TComYuv *pcOrigYuv = (TComYuv *)(Out2[0].ulpcOrigYuv); 
			
			TComYuv *pcPredYuvBest = (TComYuv *)(Out2[0].ulpcPredYuv);  //Merge模式的最佳预测
			TComYuv *pcRecoYuvBest = (TComYuv *)(Out2[0].ulpcRecoYuv);  //Merge模式的最佳
			TComYuv *pcResiYuvBest = (TComYuv *)(Out2[0].ulpcResiYuv);  //Merge模式的最佳
			
			TComDataCU* rpcTempCU;
			TComYuv *pcPredYuvTemp, *pcRecoYuvTemp, *pcResiYuvTemp;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TEncSearch类型变量
			TEncSearch m_cSearch;  //调用构造函数完成对象初始化；由于是在栈上开辟的空间，所以退出该work后自动调用析构函数进行对象析构
			TEncSearch* m_pcPredSearch = &m_cSearch; //获得指针
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//定义TcomTrQuant类型变量
			TComTrQuant m_cTrQuant;
			TComTrQuant* m_pcTrQuant = &m_cTrQuant;
			
			//m_cTrQuant.init(32,true,true,true,true,0);
			/*
			m_pcTrQuant->m_uiMaxTrSize = 32;   //需要将对应c++类中的成员变量的访问属性改为public
			m_pcTrQuant->m_useRDOQ = false;
			m_pcTrQuant->m_useRDOQTS = false;
			m_pcTrQuant->m_bEnc = true;
			m_pcTrQuant->m_useTransformSkipFast = true;
			m_pcTrQuant->m_bUseAdaptQpSelect = false;
			*/
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			//m_pcTrQuant 和 m_pcRdCost均为新创建变量的地址，而不是原m_pcEncTop下的指针
			//initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&(m_pcEncTop->m_cEntropyCoder),m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			initTEncSearch(m_pcPredSearch,m_pcEncTop,m_pcTrQuant,64,4,1,0,&m_cEntropyCoder,m_pcRdCost,m_pcEncTop->m_pppcRDSbacCoder,&(m_pcEncTop->m_cRDGoOnSbacCoder) );
			
			for(i = 1; i < 8; i++)  //将从Merge处的最佳和其他7种分割模式比较得到最佳
			{
				rpcTempCU = (TComDataCU*)(Out2[i].ulpcTempCU);
				pcPredYuvTemp = (TComYuv *)(Out2[i].ulpcPredYuv);
				pcRecoYuvTemp = (TComYuv *)(Out2[i].ulpcRecoYuv);
				pcResiYuvTemp = (TComYuv *)(Out2[i].ulpcResiYuv);
				
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
					
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);
			}
			
			destoryCurYuv_cos(pcOrigYuv);
			
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;  
		    /////////////到此，8种模式的最佳CU 获取
			
			
			rpcTempCU = (TComDataCU*)(Out2[0].ulpcBestCU);      //从4个8x8子块得到临时最佳CU
			pcPredYuvTemp = (TComYuv *)(Out2[0].ulpcPredYuvBest);  //从4个8x8子块得到临时最佳
			pcRecoYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //从4个8x8子块得到临时最佳
			pcResiYuvTemp = (TComYuv *)(Out2[0].ulpcRecoYuvBest);  //从4个8x8子块得到临时最佳
			
			//将8种模式的最佳和分割模式最佳比较 xCheckBestMode
			if( rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
			{
				TComYuv* pcYuv;
				// Change Information data
				TComDataCU* pcCU = rpcBestCU;
				rpcBestCU = rpcTempCU;
				rpcTempCU = pcCU;

				// Change Prediction data
				pcYuv = pcPredYuvBest;
				pcPredYuvBest = pcPredYuvTemp;
				pcPredYuvTemp = pcYuv;

				// Change Reconstruction data
				pcYuv = pcRecoYuvBest;
				pcRecoYuvBest = pcRecoYuvTemp;
				pcRecoYuvTemp = pcYuv;

				pcYuv = NULL;
				pcCU  = NULL;

				// store temp best CI for next CU coding
				//m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_NEXT_BEST]);
			}
			//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuvTemp);
			destoryCurYuv_cos(pcRecoYuvTemp);
			destoryCurYuv_cos(pcResiYuvTemp);
			
			//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[1][1]状态已经完成，下一个32x32块可以进行  //通过互斥变量看能否实现
			
			//同时当4个 32x32 子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
			if(++uiPartUnitIdx == 4)  
			{
				//m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
				uiPartUnitIdx = 0;
			}
			
			
			//计算最佳CU的代价值，并拷贝至Yuv
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;
				
			copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

			xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth);    //至此，一个32x32块的计算全部完成
		
			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;
		}
		window
		{
			Out2 sliding(8,8);  //输入为 join的8个分支
			Out tumbling(1);   //输出为1个最佳的32x32块
		}
	};
}

//将某一32x32最终的CU状态及YUV拷贝至上一层64x64 CU的相应位置,也即64x64的分割模式
composite copyPartTo_64x64(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out, 
                            input stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	Out = xcopyPartTo_64x64(In)
	{
		int uiPartUnitIdx;
		int uiAbsZorderIdx;  //记录处理的32x32块的起始zorder;
		UChar uiDepth;
		UChar uhWidth;
        UChar uhHeight;
		TComDataCU* rpcBestCU_64x64;
		TComYuv *pcOrigYuv;		
		TComYuv *pcPredYuvBest, *pcRecoYuvBest, *pcResiYuvBest;  
		init 
		{
			uiPartUnitIdx = 0;
			uiAbsZorderIdx = 0;
			uiDepth  = 0;
			uhWidth  = 64;
			uhHeight = 64;
			//由于帧间预测的分割模式过多，在这里只创建原始Yuv,和最佳CU, Yuv;各分支中单独开辟空间处理
			//为什么不是临时而是最佳？因为最佳CU的初始化的代价值默认是Double型的最大值；从4个8x8子块得到的代价值小于默认初始值，可以直接认为是最佳CU
			rpcBestCU_64x64 = NULL;  
			
			pcOrigYuv = NULL;  
			
			pcPredYuvBest= NULL;   pcRecoYuvBest = NULL;   pcResiYuvBest = NULL;  //16x16块的最佳, 预测,重构,残余 YUV
		}
		work
		{
	        //pcCU为LCU的指针
			
			TComPic* pcPic = pcCU->m_pcPic;
			TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			
			int y;
			Pel* pDst, *pDstU, *pDstV;
			Pel* pSrc, *pSrcU, *pSrcV;
			UInt iDstStride, iSrcStride,iWidth,iCWidth;
			
			UInt iCuAddr = pcCU->m_uiCUAddr;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			double dRdCost = 0.0; 
			
			//从 encodeRelated_32x32 的输出得到的最佳块的信息;待完成
			TComDataCU* pcSubBestPartCU = (TComDataCU*)(In[0].ulpcBestCU);
			TComYuv *pcPredYuvBest_32x32 = (TComYuv *)(In[0].ulpcPredYuvBest);
			TComYuv *pcRecoYuvBest_32x32 = (TComYuv *)(In[0].ulpcRecoYuvBest);
			TComYuv *pcResiYuvBest_32x32 = (TComYuv *)(In[0].ulpcResiYuvBest);  //根据输入完成;  //根据输入完成
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			if(uiPartUnitIdx== 0)  //说明是在处理一个新的32x32块
			{	
				createCurCU_cos(pcCU,rpcBestCU_64x64,uiDepth,uiAbsZorderIdx);  //创建最佳CU空间并初始化 , 注意使用完毕应要销毁空间
	
				createCurYuv_cos(pcOrigYuv,64,64);  //创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcPredYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcRecoYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
				
				createCurYuv_cos(pcResiYuvBest,64,64);//创建原始YUV空间并初始化，注意释放空间
				
				//pcOrigYuv 原始yuv数据拷贝
				//等价代码：m_ppcOrigYuv[2]->copyFromPicYuv( pcPic->getPicYuvOrg(), rpcBestCU->getAddr(), rpcBestCU->getZorderIdxInCU() );
			    {
					int  y;
					short* pDst  = pcOrigYuv->m_apiBufY; 
					short* pDstU = pcOrigYuv->m_apiBufU;
					short* pDstV = pcOrigYuv->m_apiBufV;
					//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
					Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_buOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
					
					//copyFromPicLuma
					UInt  iDstStride  =  pcOrigYuv->m_iWidth;
					UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
					UInt  iWidth = pcOrigYuv->m_iWidth;
					UInt  iCWidth = pcOrigYuv->m_iCWidth;
					for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
					{
						memcpy( pDst, pSrc, sizeof(short)*iWidth);
						pDst += iDstStride;
						pSrc += iSrcStride;
					}
					
					//copyFromPicChroma
					iDstStride = pcOrigYuv->m_iCWidth;
					iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
					for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
					{
						memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
						memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
						pSrcU += iSrcStride;
						pSrcV += iSrcStride;
						pDstU += iDstStride;
						pDstV += iDstStride;
					} 				
				}
				
				uiAbsZorderIdx += 64;  //每处理完一个32x32块，Zorder自增64;
				if(uiAbsZorderIdx == 256)  uiAbsZorderIdx = 0;
			}
			
			//pcSubBestPartCU为第uiPartUnitIdx个8x8子块对应的最佳CU；需要根据输入转化为对应的指针
			//rpcBestCU_64x64->copyPartFrom( pcSubBestPartCU, uiPartUnitIdx, uiDepth+1 );         // Keep best part data to current temporary data.
			copyPartFrom_cos(rpcBestCU_64x64,pcSubBestPartCU,uiPartUnitIdx,uiDepth+1);
			
			//xCopyYuv2Tmp( pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx, uiDepth+1 ); 执行：pcRecoYuvBest[uiDepth+1]->copyToPartYuv( pcRecoYuvBest[uiDepth], pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx );
			{
				
				//计算第uiPartUnitIdx个16x16子块在32x32块中对应位置
				UInt uiDstPartIdx = 16*uiPartUnitIdx; // pcSubBestPartCU->getTotalNumPart()*uiPartUnitIdx
				
				pSrc  = pcRecoYuvBest_32x32->m_apiBufY;
				pDst  =     pcRecoYuvBest->m_apiBufY + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iWidth );
				
				pSrcU = pcRecoYuvBest_32x32->m_apiBufU;
				pSrcV = pcRecoYuvBest_32x32->m_apiBufV;
				pDstU =     pcRecoYuvBest->m_apiBufU + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
				pDstV =     pcRecoYuvBest->m_apiBufV + ( g_auiRasterToPelX[g_auiZscanToRaster[uiDstPartIdx]] + g_auiRasterToPelY[g_auiZscanToRaster[uiDstPartIdx]]* pcRecoYuvBest->m_iCWidth ) >> 1;
  
				iSrcStride = pcRecoYuvBest_32x32->m_iWidth;
				iDstStride =     pcRecoYuvBest->m_iWidth;
				
				y = pcRecoYuvBest_32x32->m_iHeight;
				for( y; y!=0; y-- )
				{
					memcpy(pDst, pSrc, sizeof(Pel)*iSrcStride);
					pDst += iDstStride;
					pSrc += iSrcStride;
				}
				
				iSrcStride = pcRecoYuvBest_32x32->m_iCWidth;
				iDstStride =     pcRecoYuvBest->m_iCWidth;
				
				y = pcRecoYuvBest_32x32->m_iCHeight;
				for ( y; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iSrcStride) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iSrcStride) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				}	
			}
			
			destoryCurCU_cos(pcSubBestPartCU);
			destoryCurYuv_cos(pcPredYuvBest_32x32);
			destoryCurYuv_cos(pcRecoYuvBest_32x32);
			destoryCurYuv_cos(pcResiYuvBest_32x32);  //删除临时16x16 CU开辟的空间;并置指针为NULL，
			
			
			if(++uiPartUnitIdx == 4) //4个32x32块均接收到，对临时最佳64x64块编码
			{
				uiPartUnitIdx = 0; //重置0，用于标记下一个64x64块的开始
				
				resetBits_cos(m_pcEntropyCoder);
				encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU_64x64, 0, uiDepth, true );  // 当第3号8x8 编码后，4个8x8块拷贝至16x16临时CU中，然后对该临时CU编码，
				rpcBestCU_64x64->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
				rpcBestCU_64x64->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
				//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU_64x64->getTotalBits(), rpcBestCU_64x64->getTotalDistortion() );
				dRdCost = ((Double)rpcBestCU_64x64->m_uiTotalDistortion + (Double)((Int)(rpcBestCU_64x64->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
				dRdCost = (Double)(UInt)floor(dRdCost);
				rpcBestCU_64x64->m_dTotalCost = dRdCost;
			
				//m_pppcRDSbacCoder[uiDepth+1][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
				
				//xCheckBestMode( rpcBestCU_64x64, rpcTempCU_16x16, uiDepth);  //保存至最佳rpcBestCU_16x16
			}

			Out[0].ulpcBestCU  =  (unsigned long)rpcBestCU_64x64;	
			Out[0].ulpcOrigYuv =  (unsigned long)pcOrigYuv;
			Out[0].ulpcPredYuvBest = (unsigned long)pcPredYuvBest;
			Out[0].ulpcRecoYuvBest = (unsigned long)pcRecoYuvBest;
			Out[0].ulpcResiYuvBest = (unsigned long)pcResiYuvBest;			
		}
		window
		{
			In sliding(1,1);  //输入一个最佳的32x32并将其拷贝至64x64的相应位置
			Out tumbling(1);
		}	
	};
}

//64x64 块的帧间预测
composite xCheckRDCostInter64x64_cos(output stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
                                                   unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out, 
                                      input stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>In)
{
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest> Out1;
	Out1 = getAllSubCu_64x64(In)  //获取4个最佳的32x32块
	{
		work
		{   
			//输出由4个 32x32 块组成的临时最佳 64x64 CU，最佳YUV 地址
			Out1[0].ulpcBestCU  = In[0].ulpcBestCU;	
			Out1[0].ulpcOrigYuv = In[0].ulpcOrigYuv;
			Out1[0].ulpcPredYuvBest = In[0].ulpcPredYuvBest;
			Out1[0].ulpcRecoYuvBest = In[0].ulpcRecoYuvBest;
			Out1[0].ulpcResiYuvBest = In[0].ulpcResiYuvBest;	
		}
		window
		{
			In sliding(4,4);
			Out1 tumbling(1);
		}
	};
	Out = splitjoin(Out1)
	{
		UChar uhDepth = 0;
		int i;
		split duplicate(1);
		for(i=0; i<8; i++)
		{
			if(i == 0 ) add xCheckRDCostMerge(uhDepth);  //64x64 块的Merge模式
		    if(i == 1 ) add xCheckRDCostInter(uhDepth);  //64x64 块的2N*2N模式
			if(i == 2 ) add xCheckRDCostInter_Nx2N(uhDepth);  //64x64 块的N*2N模式
			if(i == 3 ) add xCheckRDCostInter_2NxN(uhDepth);  //64x64 块的2N*N模式
			if(i == 4 ) add xCheckRDCostInter_2NxnU(uhDepth);  //64x64 块的2NxnU模式
			if(i == 5 ) add xCheckRDCostInter_2NxnD(uhDepth);  //64x64 块的2NxnD模式
			if(i == 6 ) add xCheckRDCostInter_nLx2N(uhDepth);  //64x64 块的nLx2N模式
			if(i == 7 ) add xCheckRDCostInter_nRx2N(uhDepth);  //64x64 块的nRx2N模式
		}	
		join roundrobin(1);
	};
}

composite Main()
{
	stream<unsigned long ulpcOrigYuv> Out1;
	stream<unsigned long ulpcBestCU, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out2,Out4,Out6;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest>Out3,Out5,Out7;
	stream<unsigned long ulpcBestCU, unsigned long ulpcOrigYuv, unsigned long ulpcPredYuvBest, unsigned long ulpcRecoYuvBest, unsigned long ulpcResiYuvBest,
           unsigned long ulpcTempCU, unsigned long ulpcPredYuv, unsigned long ulpcRecoYuv, unsigned long ulpcResiYuv>Out8;
	Out1 = initSubCU_8x8()
	{
		UInt uiAbsZorderIdx;
		init
		{
			uiAbsZorderIdx = 0;
		}
		work
		{
			
			 UChar       uiDepth       = 3;
			 UChar uhWidth  = 64 >> uiDepth;
             UChar uhHeight = 64 >> uiDepth;
			 
			 TComPic* pcPic = pcCU->m_pcPic;
			 TComPicYuv* pcPicYuvSrc = pcPic->m_apcPicYuv[0];
			 Int iQP = pcCU->m_phQP[0];
			 UInt iCuAddr = pcCU->m_uiCUAddr;
			
 			 TComYuv *pcOrigYuv = NULL;  //原始YUV
			 createCurYuv_cos(pcOrigYuv,8,8);  //创建原始YUV空间并初始化，注意释放空间
			
			//原始yuv数据拷贝
			 {
				int  y;
				short* pDst  = pcOrigYuv->m_apiBufY; 
				short* pDstU = pcOrigYuv->m_apiBufU;
				short* pDstV = pcOrigYuv->m_apiBufV;
				//Pel* pSrc     = pcPicYuvSrc->getLumaAddr ( iCuAddr, uiAbsZorderIdx );
				Pel* pSrc    = pcPicYuvSrc->m_piPicOrgY + pcPicYuvSrc->m_cuOffsetY[iCuAddr] + pcPicYuvSrc->m_buOffsetY[g_auiZscanToRaster[uiAbsZorderIdx]];
				Pel* pSrcU   = pcPicYuvSrc->m_piPicOrgU + pcPicYuvSrc->m_cuOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
				Pel* pSrcV   = pcPicYuvSrc->m_piPicOrgV + pcPicYuvSrc->m_cuOffsetC[iCuAddr] + pcPicYuvSrc->m_buOffsetC[g_auiZscanToRaster[uiAbsZorderIdx]];
				
				//copyFromPicLuma
				UInt  iDstStride  =  pcOrigYuv->m_iWidth;
				UInt  iSrcStride  = pcPicYuvSrc->m_iPicWidth + (pcPicYuvSrc->m_iLumaMarginX)<<1;
				UInt  iWidth = pcOrigYuv->m_iWidth;
				UInt  iCWidth = pcOrigYuv->m_iCWidth;
				for ( y = pcOrigYuv->m_iHeight; y != 0; y-- )
				{
					memcpy( pDst, pSrc, sizeof(short)*iWidth);
                    pDst += iDstStride;
                    pSrc += iSrcStride;
                }
				
				//copyFromPicChroma
				iDstStride = pcOrigYuv->m_iCWidth;
				iSrcStride =  (pcPicYuvSrc->m_iPicWidth)>>1 + (pcPicYuvSrc->m_iChromaMarginX)<<1;
				for ( y = pcOrigYuv->m_iCHeight; y != 0; y-- )
				{
					memcpy( pDstU, pSrcU, sizeof(Pel)*(iCWidth) );
					memcpy( pDstV, pSrcV, sizeof(Pel)*(iCWidth) );
					pSrcU += iSrcStride;
					pSrcV += iSrcStride;
					pDstU += iDstStride;
					pDstV += iDstStride;
				} 				
			 }
			 
			Out1[0].ulpcOrigYuv = (unsigned long)pcOrigYuv;
			 
			uiAbsZorderIdx += 4;  //每处理完一个8x8块，Zorder自增4;
			if(uiAbsZorderIdx == 256) uiAbsZorderIdx = 0;
		} 
		window
		{
			Out1 tumbling(1);
		}
	};
	
	
	Out2 = xCheckRDCostInter8x8_cos(Out1)();
	
	Out3 = copyPartTo_16x16(Out2)();
	
	Out4 = xCheckRDCostInter16x16_cos(Out3)();
	
	
	Out5 = copyPartTo_32x32(Out4)();
	
	Out6 = xCheckRDCostInter32x32_cos(Out5)();
	
	Out7 = copyPartTo_64x64(Out6)();
	
	Out8 = xCheckRDCostInter64x64_cos(Out7)();
	
	encodeRelated_64x64(Out8)
	{
		int uiPartUnitIdx;  //记录处理的个数
		init
		{
			uiPartUnitIdx = 0;
		}
		work
		{
			//根据输入获得熵编码器指针，两个临时CU,rpcTempCU_F(对应原rpcTempCU_2Nx2N_8x8),rpcTempCU_S(对应原rpcTempCU_NxN_8x8),
			//对应的临时YUV为pcPredYuv, pcRecoYuv, pcResiYuv, pcPredYuv_NxN, pcRecoYuv_NxN, pcResiYuv_NxN
			//最佳CU：rpcBestCU, pcPredYuv_NxN,pcResiYuvBest,pcRecoYuvBest
			UInt uiDepth = 0; //rpcTempCU_F-> m_puhDepth[0];  
			double dRdCost;
			int i = 0;
			
			//定义编码器
			TEncEntropy m_cEntropyCoder;
			TEncEntropy *m_pcEntropyCoder = &m_cEntropyCoder;
			
			//定义TComRdCost类型变量
			TComRdCost m_cRdCost;
			TComRdCost* m_pcRdCost = &m_cRdCost;
			
			//rpcBestCU 用于保存各种模式中的最佳，并未开辟空间,初始设为从join的第一个分支，initTComRdCost即Merge处得到的最佳
			TComDataCU* rpcBestCU  = (TComDataCU*)(Out8[0].ulpcTempCU);  // Out8[0]  
			TComYuv *pcOrigYuv = (TComYuv *)(Out8[0].ulpcOrigYuv); 
			TComYuv *pcPredYuvBest = (TComYuv *)(Out8[0].ulpcPredYuv);  //Merge模式的最佳预测
			TComYuv *pcRecoYuvBest = (TComYuv *)(Out8[0].ulpcRecoYuv);  //Merge模式的最佳
			TComYuv *pcResiYuvBest = (TComYuv *)(Out8[0].ulpcResiYuv);  //Merge模式的最佳
			
			TComDataCU* rpcTempCU;
			TComYuv *pcPredYuvTemp, *pcRecoYuvTemp, *pcResiYuvTemp;
			
			initTComRdCost(m_pcRdCost,g_m_pcRdCost);
			
			for(i = 1; i < 8; i++)  //将从Merge处的最佳和其他7种分割模式比较得到最佳
			{
				rpcTempCU = (TComDataCU*)(Out8[i].ulpcTempCU);
				pcPredYuvTemp = (TComYuv *)(Out8[i].ulpcPredYuv);
				pcRecoYuvTemp = (TComYuv *)(Out8[i].ulpcRecoYuv);
				pcResiYuvTemp = (TComYuv *)(Out8[i].ulpcResiYuv);
				
				if(rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost)
				{
					TComYuv* pcYuv;
					// Change Information data
					TComDataCU* pcCU = rpcBestCU;
					rpcBestCU = rpcTempCU;
					rpcTempCU = pcCU;

					// Change Prediction data
					pcYuv = pcPredYuvBest;
					pcPredYuvBest = pcPredYuvTemp;
					pcPredYuvTemp = pcYuv;

					// Change Reconstruction data
					pcYuv = pcRecoYuvBest;
					pcRecoYuvBest = pcRecoYuvTemp;
					pcRecoYuvTemp = pcYuv;

					pcYuv = NULL;
					pcCU  = NULL;
					
					// store temp best CI for next CU coding
					store_cos(m_pppcRDSbacCoder[uiDepth][2],m_pppcRDSbacCoder[uiDepth][1]);   
				}
				//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
				destoryCurCU_cos(rpcTempCU);
				destoryCurYuv_cos(pcPredYuvTemp);
				destoryCurYuv_cos(pcRecoYuvTemp);
				destoryCurYuv_cos(pcResiYuvTemp);
			}
			
			destoryCurYuv_cos(pcOrigYuv);
			
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;  
		    /////////////到此，8种模式的最佳CU 获取
			
			rpcTempCU = (TComDataCU*)(Out8[0].ulpcBestCU);      //从4个  32x32 子块得到临时最佳CU
			pcPredYuvTemp = (TComYuv *)(Out8[0].ulpcPredYuvBest);  //从4个 32x32 子块得到临时最佳
			pcRecoYuvTemp = (TComYuv *)(Out8[0].ulpcRecoYuvBest);  //从4个 32x32 子块得到临时最佳
			pcResiYuvTemp = (TComYuv *)(Out8[0].ulpcRecoYuvBest);  //从4个 32x32 子块得到临时最佳
			
			//将8种模式的最佳和分割模式最佳比较 xCheckBestMode
			if( rpcTempCU->m_dTotalCost < rpcBestCU->m_dTotalCost )
			{
				TComYuv* pcYuv;
				// Change Information data
				TComDataCU* pcCU = rpcBestCU;
				rpcBestCU = rpcTempCU;
				rpcTempCU = pcCU;

				// Change Prediction data
				pcYuv = pcPredYuvBest;
				pcPredYuvBest = pcPredYuvTemp;
				pcPredYuvTemp = pcYuv;

				// Change Reconstruction data
				pcYuv = pcRecoYuvBest;
				pcRecoYuvBest = pcRecoYuvTemp;
				pcRecoYuvTemp = pcYuv;

				pcYuv = NULL;
				pcCU  = NULL;

				// store temp best CI for next CU coding
				//m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_NEXT_BEST]);
			}
			
			//destoryCuYuv_cos(rpcTempCU,pcPredYuvTemp,pcRecoYuvTemp,pcResiYuvTemp) ;  //删除临时CU开辟的空间;并置指针为NULL，
			destoryCurCU_cos(rpcTempCU);
			destoryCurYuv_cos(pcPredYuvTemp);
			destoryCurYuv_cos(pcRecoYuvTemp);
			destoryCurYuv_cos(pcResiYuvTemp);
			
			
			//事实上到该for循环结束时CI_NEXT_BEST已获取,即m_pppcRDSbacCoder[1][1]状态已经完成，下一个32x32块可以进行  //通过互斥变量看能否实现
			
			//同时当4个 32x32 子块均处理时，可以将状态传至上一层，原代码为m_pppcRDSbacCoder[uhNextDepth][CI_NEXT_BEST]->store(m_pppcRDSbacCoder[uiDepth][CI_TEMP_BEST]);
			
			//if(++uiPartUnitIdx == 4)  
			//{
			//	m_pppcRDSbacCoder[uiDepth][1]->store(m_pppcRDSbacCoder[uiDepth-1][2]);
			//	uiPartUnitIdx = 0;
			//}
			
			
			//计算最佳CU的代价值，并拷贝至Yuv
			resetBits_cos(m_pcEntropyCoder);
			encodeSplitFlag_cos(m_pcEntropyCoder,rpcBestCU, 0, uiDepth, true );  
			rpcBestCU->m_uiTotalBits += getNumberOfWrittenBits_cos(m_pcEntropyCoder); // split bits
			rpcBestCU->m_uiTotalBins += getBinsCoded_cos(m_pcEntropyCoder);
			//rpcBestCU->getTotalCost()  = m_pcRdCost->calcRdCost( rpcBestCU->getTotalBits(), rpcBestCU->getTotalDistortion() );
			dRdCost = ((Double)rpcBestCU->m_uiTotalDistortion + (Double)((Int)(rpcBestCU->m_uiTotalBits * (m_pcRdCost->m_dLambda)+.5)));
			dRdCost = (Double)(UInt)floor(dRdCost);
			rpcBestCU->m_dTotalCost = dRdCost;
				
			copyToPic_cos(rpcBestCU,uiDepth);                                                     // Copy Best data to Picture for next partition prediction.

			xCopyYuv2Pic_cos(m_pcCuEncoder,rpcBestCU,uiDepth);    //至此，一个64x64块的计算全部完成
		
		
			//删除第0层的最佳CU，Yuv
			//destoryCuYuv_cos(rpcBestCU,pcPredYuvBest,pcRecoYuvBest,pcResiYuvBest);
			destoryCurCU_cos(rpcBestCU);
			destoryCurYuv_cos(pcPredYuvBest);
			destoryCurYuv_cos(pcRecoYuvBest);
			destoryCurYuv_cos(pcResiYuvBest);
				
		}
		window
		{
			Out8 sliding(8,8);  //输入为 join的8个分支
		}
	};
	/*Sink(Out8)
	{
		work
		{
			
		}
	};
	*/
}